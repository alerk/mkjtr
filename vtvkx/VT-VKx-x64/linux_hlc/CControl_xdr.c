/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "CControl.h"

bool_t
xdr_MkjtricDataTypeCctrl (XDR *xdrs, MkjtricDataTypeCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DetDataStruct (XDR *xdrs, DetDataStruct *objp)
{
	register int32_t *buf;

	 if (!xdr_short (xdrs, &objp->subTicks))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->value))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DetValuesPerChannel (XDR *xdrs, DetValuesPerChannel *objp)
{
	register int32_t *buf;

	 if (!xdr_quad_t (xdrs, &objp->TicksOfLastChange))
		 return FALSE;
	 if (!xdr_short (xdrs, &objp->nr))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->detDatas.detDatas_val, (u_int *) &objp->detDatas.detDatas_len, 256,
		sizeof (DetDataStruct), (xdrproc_t) xdr_DetDataStruct))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DetectorErrorCodeCctrl (XDR *xdrs, DetectorErrorCodeCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DetStatusCctrl (XDR *xdrs, DetStatusCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->channel))
		 return FALSE;
	 if (!xdr_u_char (xdrs, &objp->quality))
		 return FALSE;
	 if (!xdr_DetectorErrorCodeCctrl (xdrs, &objp->errorCode))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DetRawValuesExchg (XDR *xdrs, DetRawValuesExchg *objp)
{
	register int32_t *buf;

	 if (!xdr_quad_t (xdrs, &objp->absTimeDevTicks))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->detDatas.detDatas_val, (u_int *) &objp->detDatas.detDatas_len, 256,
		sizeof (DetValuesPerChannel), (xdrproc_t) xdr_DetValuesPerChannel))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->detStatus.detStatus_val, (u_int *) &objp->detStatus.detStatus_len, 256,
		sizeof (DetStatusCctrl), (xdrproc_t) xdr_DetStatusCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RetCodeCctrl (XDR *xdrs, RetCodeCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_IntersectionOperatingModeCctrl (XDR *xdrs, IntersectionOperatingModeCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_SummaryAlarmCctrl (XDR *xdrs, SummaryAlarmCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TypeOfModificationCctrl (XDR *xdrs, TypeOfModificationCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_SubIntersectionDetailStateCctrl (XDR *xdrs, SubIntersectionDetailStateCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ModOnOffStateCctrl (XDR *xdrs, ModOnOffStateCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_IntersectionStateCctrl (XDR *xdrs, IntersectionStateCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TTVSubIntersectionDetailStateCctrl (XDR *xdrs, TTVSubIntersectionDetailStateCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->subintersectionNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_SubIntersectionDetailStateCctrl (xdrs, &objp->value))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TTVModOnOffStateCctrl (XDR *xdrs, TTVModOnOffStateCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_TypeOfModificationCctrl (xdrs, &objp->modType))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->modNo))
		 return FALSE;
	 if (!xdr_ModOnOffStateCctrl (xdrs, &objp->value))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TTVModOnOffStateCctrlA (XDR *xdrs, TTVModOnOffStateCctrlA *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->TTVModOnOffStateCctrlA_val, (u_int *) &objp->TTVModOnOffStateCctrlA_len, 16,
		sizeof (TTVModOnOffStateCctrl), (xdrproc_t) xdr_TTVModOnOffStateCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ActualStatusCctrl (XDR *xdrs, ActualStatusCctrl *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_quad_t (xdrs, &objp->tickTimeOfLastChange))
			 return FALSE;
		 if (!xdr_SummaryAlarmCctrl (xdrs, &objp->globalFaultState))
			 return FALSE;
		 if (!xdr_int (xdrs, &objp->operatingModeSysJobId))
			 return FALSE;
		 if (!xdr_IntersectionOperatingModeCctrl (xdrs, &objp->operatingMode))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->signalProgramSysJobId))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->signalProgram))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->intersectionOnOffStateSysJobId))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->signalProgramSysJobId);
		IXDR_PUT_LONG(buf, objp->signalProgram);
		IXDR_PUT_LONG(buf, objp->intersectionOnOffStateSysJobId);
		}
		 if (!xdr_IntersectionStateCctrl (xdrs, &objp->intersectionOnOffState))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->subIntersectionStates.subIntersectionStates_val, (u_int *) &objp->subIntersectionStates.subIntersectionStates_len, 4,
			sizeof (TTVSubIntersectionDetailStateCctrl), (xdrproc_t) xdr_TTVSubIntersectionDetailStateCctrl))
			 return FALSE;
		 if (!xdr_int (xdrs, &objp->specialInterventionSysJobId))
			 return FALSE;
		 if (!xdr_int (xdrs, &objp->specialIntervention))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->modifications.modifications_val, (u_int *) &objp->modifications.modifications_len, 17,
			sizeof (TTVModOnOffStateCctrl), (xdrproc_t) xdr_TTVModOnOffStateCctrl))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_quad_t (xdrs, &objp->tickTimeOfLastChange))
			 return FALSE;
		 if (!xdr_SummaryAlarmCctrl (xdrs, &objp->globalFaultState))
			 return FALSE;
		 if (!xdr_int (xdrs, &objp->operatingModeSysJobId))
			 return FALSE;
		 if (!xdr_IntersectionOperatingModeCctrl (xdrs, &objp->operatingMode))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->signalProgramSysJobId))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->signalProgram))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->intersectionOnOffStateSysJobId))
				 return FALSE;

		} else {
		objp->signalProgramSysJobId = IXDR_GET_LONG(buf);
		objp->signalProgram = IXDR_GET_LONG(buf);
		objp->intersectionOnOffStateSysJobId = IXDR_GET_LONG(buf);
		}
		 if (!xdr_IntersectionStateCctrl (xdrs, &objp->intersectionOnOffState))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->subIntersectionStates.subIntersectionStates_val, (u_int *) &objp->subIntersectionStates.subIntersectionStates_len, 4,
			sizeof (TTVSubIntersectionDetailStateCctrl), (xdrproc_t) xdr_TTVSubIntersectionDetailStateCctrl))
			 return FALSE;
		 if (!xdr_int (xdrs, &objp->specialInterventionSysJobId))
			 return FALSE;
		 if (!xdr_int (xdrs, &objp->specialIntervention))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->modifications.modifications_val, (u_int *) &objp->modifications.modifications_len, 17,
			sizeof (TTVModOnOffStateCctrl), (xdrproc_t) xdr_TTVModOnOffStateCctrl))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_quad_t (xdrs, &objp->tickTimeOfLastChange))
		 return FALSE;
	 if (!xdr_SummaryAlarmCctrl (xdrs, &objp->globalFaultState))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->operatingModeSysJobId))
		 return FALSE;
	 if (!xdr_IntersectionOperatingModeCctrl (xdrs, &objp->operatingMode))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->signalProgramSysJobId))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->signalProgram))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->intersectionOnOffStateSysJobId))
		 return FALSE;
	 if (!xdr_IntersectionStateCctrl (xdrs, &objp->intersectionOnOffState))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->subIntersectionStates.subIntersectionStates_val, (u_int *) &objp->subIntersectionStates.subIntersectionStates_len, 4,
		sizeof (TTVSubIntersectionDetailStateCctrl), (xdrproc_t) xdr_TTVSubIntersectionDetailStateCctrl))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->specialInterventionSysJobId))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->specialIntervention))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->modifications.modifications_val, (u_int *) &objp->modifications.modifications_len, 17,
		sizeof (TTVModOnOffStateCctrl), (xdrproc_t) xdr_TTVModOnOffStateCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MsgParamTypeInfoCctrl (XDR *xdrs, MsgParamTypeInfoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MsgParamTypeRefCctrl (XDR *xdrs, MsgParamTypeRefCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->member))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->oType))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->path.path_val, (u_int *) &objp->path.path_len, ~0,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MsgParamTypeEnumCctrl (XDR *xdrs, MsgParamTypeEnumCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->ordinal))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->name, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MsgParameterValueCctrl (XDR *xdrs, MsgParameterValueCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_MsgParamTypeInfoCctrl (xdrs, &objp->typeInfo))
		 return FALSE;
	switch (objp->typeInfo) {
	case MPTI_BYTE:
	case MPTI_UBYTE:
	case MPTI_SHORT:
	case MPTI_USHORT:
	case MPTI_LONG:
	case MPTI_ULONG:
	case MPTI_SYSJOBID:
		 if (!xdr_int (xdrs, &objp->MsgParameterValueCctrl_u.intValue))
			 return FALSE;
		break;
	case MPTI_BOOL:
		 if (!xdr_bool (xdrs, &objp->MsgParameterValueCctrl_u.boolValue))
			 return FALSE;
		break;
	case MPTI_UTC:
		 if (!xdr_quad_t (xdrs, &objp->MsgParameterValueCctrl_u.timeStamp))
			 return FALSE;
		break;
	case MPTI_FLOAT:
		 if (!xdr_float (xdrs, &objp->MsgParameterValueCctrl_u.fValue))
			 return FALSE;
		break;
	case MPTI_DOUBLE:
		 if (!xdr_double (xdrs, &objp->MsgParameterValueCctrl_u.dValue))
			 return FALSE;
		break;
	case MPTI_CHECKSUM:
		 if (!xdr_array (xdrs, (char **)&objp->MsgParameterValueCctrl_u.checkSum.checkSum_val, (u_int *) &objp->MsgParameterValueCctrl_u.checkSum.checkSum_len, 20,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		break;
	case MPTI_STRING:
		 if (!xdr_string (xdrs, &objp->MsgParameterValueCctrl_u.strValue, ~0))
			 return FALSE;
		break;
	case MPTI_REFERENCE:
		 if (!xdr_MsgParamTypeRefCctrl (xdrs, &objp->MsgParameterValueCctrl_u.reference))
			 return FALSE;
		break;
	case MPTI_ENUM:
		 if (!xdr_MsgParamTypeEnumCctrl (xdrs, &objp->MsgParameterValueCctrl_u.enumValue))
			 return FALSE;
		break;
	case MPTI_INT64:
		 if (!xdr_quad_t (xdrs, &objp->MsgParameterValueCctrl_u.int64Value))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_MsgParameterCctrl (XDR *xdrs, MsgParameterCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->name, ~0))
		 return FALSE;
	 if (!xdr_MsgParameterValueCctrl (xdrs, &objp->value))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CommonStatusCctrl (XDR *xdrs, CommonStatusCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_quad_t (xdrs, &objp->tickTimeOfLastChange))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->otype))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->value))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_LampFaultStateCctrl (XDR *xdrs, LampFaultStateCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_LampFaultTimeConstraintsCctrl (XDR *xdrs, LampFaultTimeConstraintsCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_LampStatusCctrl (XDR *xdrs, LampStatusCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_quad_t (xdrs, &objp->tickTimeOfLastChange))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sgNo))
		 return FALSE;
	 if (!xdr_LampFaultTimeConstraintsCctrl (xdrs, &objp->tcRed))
		 return FALSE;
	 if (!xdr_LampFaultTimeConstraintsCctrl (xdrs, &objp->tcAmber))
		 return FALSE;
	 if (!xdr_LampFaultTimeConstraintsCctrl (xdrs, &objp->tcGreen))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->redHeads.redHeads_val, (u_int *) &objp->redHeads.redHeads_len, 4,
		sizeof (LampFaultStateCctrl), (xdrproc_t) xdr_LampFaultStateCctrl))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->amberHeads.amberHeads_val, (u_int *) &objp->amberHeads.amberHeads_len, 4,
		sizeof (LampFaultStateCctrl), (xdrproc_t) xdr_LampFaultStateCctrl))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->greenHeads.greenHeads_val, (u_int *) &objp->greenHeads.greenHeads_len, 4,
		sizeof (LampFaultStateCctrl), (xdrproc_t) xdr_LampFaultStateCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_SpeedVolumeCctrl (XDR *xdrs, SpeedVolumeCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_short (xdrs, &objp->speed))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->volume))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DetectorAggregationCctrl (XDR *xdrs, DetectorAggregationCctrl *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_short (xdrs, &objp->nr))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->volume))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->occupanceRate))
				 return FALSE;

		} else {
		IXDR_PUT_SHORT(buf, objp->nr);
		IXDR_PUT_LONG(buf, objp->volume);
		IXDR_PUT_LONG(buf, objp->occupanceRate);
		}
		 if (!xdr_u_char (xdrs, &objp->quality))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->sv.sv_val, (u_int *) &objp->sv.sv_len, ~0,
			sizeof (SpeedVolumeCctrl), (xdrproc_t) xdr_SpeedVolumeCctrl))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_short (xdrs, &objp->nr))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->volume))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->occupanceRate))
				 return FALSE;

		} else {
		objp->nr = IXDR_GET_SHORT(buf);
		objp->volume = IXDR_GET_LONG(buf);
		objp->occupanceRate = IXDR_GET_LONG(buf);
		}
		 if (!xdr_u_char (xdrs, &objp->quality))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->sv.sv_val, (u_int *) &objp->sv.sv_len, ~0,
			sizeof (SpeedVolumeCctrl), (xdrproc_t) xdr_SpeedVolumeCctrl))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_short (xdrs, &objp->nr))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->volume))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->occupanceRate))
		 return FALSE;
	 if (!xdr_u_char (xdrs, &objp->quality))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->sv.sv_val, (u_int *) &objp->sv.sv_len, ~0,
		sizeof (SpeedVolumeCctrl), (xdrproc_t) xdr_SpeedVolumeCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_AggregationCycleCctrl (XDR *xdrs, AggregationCycleCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->samplingInterval))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->offset))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_AggregationCycleResultCctrl (XDR *xdrs, AggregationCycleResultCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_RetCodeCctrl (xdrs, &objp->retCode))
		 return FALSE;
	switch (objp->retCode) {
	case RC_OK:
		 if (!xdr_AggregationCycleCctrl (xdrs, &objp->AggregationCycleResultCctrl_u.ac))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_AggregationSignallingResultCctrl (XDR *xdrs, AggregationSignallingResultCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_RetCodeCctrl (xdrs, &objp->retCode))
		 return FALSE;
	switch (objp->retCode) {
	case RC_OK:
		 if (!xdr_int (xdrs, &objp->AggregationSignallingResultCctrl_u.maxSamplinInterval))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_DetRawValuesGradedCctrl (XDR *xdrs, DetRawValuesGradedCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_short (xdrs, &objp->nr))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_u_char (xdrs, &objp->quality))
		 return FALSE;
	 if (!xdr_DetectorErrorCodeCctrl (xdrs, &objp->errorCode))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->TicksOfLastChange))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->detDatas.detDatas_val, (u_int *) &objp->detDatas.detDatas_len, 256,
		sizeof (DetDataStruct), (xdrproc_t) xdr_DetDataStruct))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_SignalIndicationCctrl (XDR *xdrs, SignalIndicationCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sgNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->ocitColor))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->colorStartTime))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_SignalIndicationsCctrl (XDR *xdrs, SignalIndicationsCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_quad_t (xdrs, &objp->baseTicktime))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->baseUtcMinusTicktime))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->tx))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->sgPatterns.sgPatterns_val, (u_int *) &objp->sgPatterns.sgPatterns_len, 64,
		sizeof (SignalIndicationCctrl), (xdrproc_t) xdr_SignalIndicationCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MkjtricActuationComponentParams (XDR *xdrs, MkjtricActuationComponentParams *objp)
{
	register int32_t *buf;

	 if (!xdr_bytes (xdrs, (char **)&objp->componentParams.componentParams_val, (u_int *) &objp->componentParams.componentParams_len, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_MkjtricActuationComponentParamsResult (XDR *xdrs, MkjtricActuationComponentParamsResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RetCodeCctrl (xdrs, &objp->retCode))
		 return FALSE;
	switch (objp->retCode) {
	case RC_OK:
		 if (!xdr_MkjtricActuationComponentParams (xdrs, &objp->MkjtricActuationComponentParamsResult_u.tacp))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_InitiatorCCtrl (XDR *xdrs, InitiatorCCtrl *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->format, ~0))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->params.params_val, (u_int *) &objp->params.params_len, ~0,
		sizeof (MsgParameterValueCctrl), (xdrproc_t) xdr_MsgParameterValueCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ExternalSgSwitchingEvent (XDR *xdrs, ExternalSgSwitchingEvent *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_int (xdrs, &objp->priority))
			 return FALSE;
		 if (!xdr_quad_t (xdrs, &objp->startTickTime))
			 return FALSE;
		 if (!xdr_quad_t (xdrs, &objp->validDuration))
			 return FALSE;
		 if (!xdr_InitiatorCCtrl (xdrs, &objp->initiator))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->signalGroupNumber))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->signalIndication))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isWithTransition))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isWithCorrection))
				 return FALSE;
		} else {
			IXDR_PUT_LONG(buf, objp->signalGroupNumber);
			IXDR_PUT_LONG(buf, objp->signalIndication);
			IXDR_PUT_BOOL(buf, objp->isWithTransition);
			IXDR_PUT_BOOL(buf, objp->isWithCorrection);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_int (xdrs, &objp->priority))
			 return FALSE;
		 if (!xdr_quad_t (xdrs, &objp->startTickTime))
			 return FALSE;
		 if (!xdr_quad_t (xdrs, &objp->validDuration))
			 return FALSE;
		 if (!xdr_InitiatorCCtrl (xdrs, &objp->initiator))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->signalGroupNumber))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->signalIndication))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isWithTransition))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isWithCorrection))
				 return FALSE;
		} else {
			objp->signalGroupNumber = IXDR_GET_LONG(buf);
			objp->signalIndication = IXDR_GET_LONG(buf);
			objp->isWithTransition = IXDR_GET_BOOL(buf);
			objp->isWithCorrection = IXDR_GET_BOOL(buf);
		}
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->startTickTime))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->validDuration))
		 return FALSE;
	 if (!xdr_InitiatorCCtrl (xdrs, &objp->initiator))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->signalGroupNumber))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->signalIndication))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isWithTransition))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isWithCorrection))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ExternalSgSwitchingEventArray (XDR *xdrs, ExternalSgSwitchingEventArray *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->ExternalSgSwitchingEventArray_val, (u_int *) &objp->ExternalSgSwitchingEventArray_len, ~0,
		sizeof (ExternalSgSwitchingEvent), (xdrproc_t) xdr_ExternalSgSwitchingEvent))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ExternalStageSwitchingEvent (XDR *xdrs, ExternalStageSwitchingEvent *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->startTickTime))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->validDuration))
		 return FALSE;
	 if (!xdr_InitiatorCCtrl (xdrs, &objp->initiator))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->stageNumber))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ExternalStageSwitchingEventArray (XDR *xdrs, ExternalStageSwitchingEventArray *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->ExternalStageSwitchingEventArray_val, (u_int *) &objp->ExternalStageSwitchingEventArray_len, ~0,
		sizeof (ExternalStageSwitchingEvent), (xdrproc_t) xdr_ExternalStageSwitchingEvent))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TargetStage (XDR *xdrs, TargetStage *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->stageNo))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->stageStartTime))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->nextStageNo))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->stageTransitionStartTime))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->stageTransitionDuration))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isStageSignalIndication))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TargetStagePtr (XDR *xdrs, TargetStagePtr *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)objp, sizeof (TargetStage), (xdrproc_t) xdr_TargetStage))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TypeOfViolation (XDR *xdrs, TypeOfViolation *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RequestedModificationStateCctrl (XDR *xdrs, RequestedModificationStateCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RequestedNodeStateCctrl (XDR *xdrs, RequestedNodeStateCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RequestedMainNodeStateCctrl (XDR *xdrs, RequestedMainNodeStateCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RequestedStatusModNoCctrl (XDR *xdrs, RequestedStatusModNoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TimeConstrainedTransactionTaggedIntValueCctrl (XDR *xdrs, TimeConstrainedTransactionTaggedIntValueCctrl *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->value))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->sysJobId))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->priority))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->value);
		IXDR_PUT_LONG(buf, objp->sysJobId);
		IXDR_PUT_LONG(buf, objp->priority);
		}
		 if (!xdr_quad_t (xdrs, &objp->validUntilDeviceTime))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->value))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->sysJobId))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->priority))
				 return FALSE;

		} else {
		objp->value = IXDR_GET_LONG(buf);
		objp->sysJobId = IXDR_GET_LONG(buf);
		objp->priority = IXDR_GET_LONG(buf);
		}
		 if (!xdr_quad_t (xdrs, &objp->validUntilDeviceTime))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->validUntilDeviceTime))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TcTTVModOnOffStateCctrl (XDR *xdrs, TcTTVModOnOffStateCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_RequestedModificationStateCctrl (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->validUntilDeviceTime))
		 return FALSE;
	 if (!xdr_RequestedStatusModNoCctrl (xdrs, &objp->modType))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->modNo))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RequestedStatusCctrl (XDR *xdrs, RequestedStatusCctrl *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_TimeConstrainedTransactionTaggedIntValueCctrl (xdrs, &objp->intersectionState))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->modState.modState_val, (u_int *) &objp->modState.modState_len, 17,
		sizeof (TcTTVModOnOffStateCctrl), (xdrproc_t) xdr_TcTTVModOnOffStateCctrl))
		 return FALSE;
	 if (!xdr_TimeConstrainedTransactionTaggedIntValueCctrl (xdrs, &objp->signalProgram))
		 return FALSE;
	 if (!xdr_TimeConstrainedTransactionTaggedIntValueCctrl (xdrs, &objp->specialIntervention))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->subIntersectionState, 4,
		sizeof (TimeConstrainedTransactionTaggedIntValueCctrl), (xdrproc_t) xdr_TimeConstrainedTransactionTaggedIntValueCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RequestedStatusPriorityCctrl (XDR *xdrs, RequestedStatusPriorityCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ConfigType (XDR *xdrs, ConfigType *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CheckResult (XDR *xdrs, CheckResult *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_UnitId (XDR *xdrs, UnitId *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_SeverityCctrl (XDR *xdrs, SeverityCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgMessageCctrl (XDR *xdrs, CfgMessageCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_SeverityCctrl (xdrs, &objp->severity))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->ticks))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysjobid))
		 return FALSE;
	 if (!xdr_InitiatorCCtrl (xdrs, &objp->msg))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CheckRespondCctrl (XDR *xdrs, CheckRespondCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_CheckResult (xdrs, &objp->result))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->Messages.Messages_val, (u_int *) &objp->Messages.Messages_len, ~0,
		sizeof (CfgMessageCctrl), (xdrproc_t) xdr_CfgMessageCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CltStatusMsgsCctrl (XDR *xdrs, CltStatusMsgsCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_UnitId (xdrs, &objp->unit))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->msgs.msgs_val, (u_int *) &objp->msgs.msgs_len, ~0,
		sizeof (CfgMessageCctrl), (xdrproc_t) xdr_CfgMessageCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_SignalGroupDetailTypeCctrl (XDR *xdrs, SignalGroupDetailTypeCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgSgInfo (XDR *xdrs, CfgSgInfo *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sgNo))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->greenStateColors.greenStateColors_val, (u_int *) &objp->greenStateColors.greenStateColors_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->redStateColors.redStateColors_val, (u_int *) &objp->redStateColors.redStateColors_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgSgStateTransitionElementCCtrl (XDR *xdrs, CfgSgStateTransitionElementCCtrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->color))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->duration_100ms))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgSgStateTransitionCCtrl (XDR *xdrs, CfgSgStateTransitionCCtrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->no))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->elements.elements_val, (u_int *) &objp->elements.elements_len, ~0,
		sizeof (CfgSgStateTransitionElementCCtrl), (xdrproc_t) xdr_CfgSgStateTransitionElementCCtrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgSgInfo2CCtrl (XDR *xdrs, CfgSgInfo2CCtrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sgNo))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->name, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->partialIntersectionNo))
		 return FALSE;
	 if (!xdr_SignalGroupDetailTypeCctrl (xdrs, &objp->sgType))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isMainDirection))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->greenStateColors.greenStateColors_val, (u_int *) &objp->greenStateColors.greenStateColors_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->redStateColors.redStateColors_val, (u_int *) &objp->redStateColors.redStateColors_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->transGnRd.transGnRd_val, (u_int *) &objp->transGnRd.transGnRd_len, ~0,
		sizeof (CfgSgStateTransitionCCtrl), (xdrproc_t) xdr_CfgSgStateTransitionCCtrl))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->transRdGn.transRdGn_val, (u_int *) &objp->transRdGn.transRdGn_len, ~0,
		sizeof (CfgSgStateTransitionCCtrl), (xdrproc_t) xdr_CfgSgStateTransitionCCtrl))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->minGreen.minGreen_val, (u_int *) &objp->minGreen.minGreen_len, ~0,
		sizeof (CfgSgStateTransitionCCtrl), (xdrproc_t) xdr_CfgSgStateTransitionCCtrl))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->minRed.minRed_val, (u_int *) &objp->minRed.minRed_len, ~0,
		sizeof (CfgSgStateTransitionCCtrl), (xdrproc_t) xdr_CfgSgStateTransitionCCtrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgSgDetParam (XDR *xdrs, CfgSgDetParam *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->sgNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->detNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->demandResetThreshold))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->runningGapThreshold))
				 return FALSE;
		} else {
			IXDR_PUT_LONG(buf, objp->sgNo);
			IXDR_PUT_LONG(buf, objp->detNo);
			IXDR_PUT_LONG(buf, objp->demandResetThreshold);
			IXDR_PUT_LONG(buf, objp->runningGapThreshold);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->sgNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->detNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->demandResetThreshold))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->runningGapThreshold))
				 return FALSE;
		} else {
			objp->sgNo = IXDR_GET_LONG(buf);
			objp->detNo = IXDR_GET_LONG(buf);
			objp->demandResetThreshold = IXDR_GET_LONG(buf);
			objp->runningGapThreshold = IXDR_GET_LONG(buf);
		}
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->sgNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->detNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->demandResetThreshold))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->runningGapThreshold))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgSignalisation (XDR *xdrs, CfgSignalisation *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sgNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->color))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgStage (XDR *xdrs, CfgStage *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->stageNo))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->signalisations.signalisations_val, (u_int *) &objp->signalisations.signalisations_len, ~0,
		sizeof (CfgSignalisation), (xdrproc_t) xdr_CfgSignalisation))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgStageSequenceElement2 (XDR *xdrs, CfgStageSequenceElement2 *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 10 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->stageSequenceElementNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->stageNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->minDuration_100ms))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->maxDuration_100ms))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isExtendable))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isMandatory))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->extendableStageDuration_100ms))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isAddTimeToPredecessor))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isAddTimeToFollower))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isFixedOrderStage))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->stageSequenceElementNo);
		IXDR_PUT_LONG(buf, objp->stageNo);
		IXDR_PUT_LONG(buf, objp->minDuration_100ms);
		IXDR_PUT_LONG(buf, objp->maxDuration_100ms);
		IXDR_PUT_BOOL(buf, objp->isExtendable);
		IXDR_PUT_BOOL(buf, objp->isMandatory);
		IXDR_PUT_LONG(buf, objp->extendableStageDuration_100ms);
		IXDR_PUT_BOOL(buf, objp->isAddTimeToPredecessor);
		IXDR_PUT_BOOL(buf, objp->isAddTimeToFollower);
		IXDR_PUT_BOOL(buf, objp->isFixedOrderStage);
		}
		 if (!xdr_array (xdrs, (char **)&objp->demandedByPtDirection.demandedByPtDirection_val, (u_int *) &objp->demandedByPtDirection.demandedByPtDirection_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->sgOnDemandList.sgOnDemandList_val, (u_int *) &objp->sgOnDemandList.sgOnDemandList_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 10 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->stageSequenceElementNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->stageNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->minDuration_100ms))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->maxDuration_100ms))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isExtendable))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isMandatory))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->extendableStageDuration_100ms))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isAddTimeToPredecessor))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isAddTimeToFollower))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isFixedOrderStage))
				 return FALSE;

		} else {
		objp->stageSequenceElementNo = IXDR_GET_LONG(buf);
		objp->stageNo = IXDR_GET_LONG(buf);
		objp->minDuration_100ms = IXDR_GET_LONG(buf);
		objp->maxDuration_100ms = IXDR_GET_LONG(buf);
		objp->isExtendable = IXDR_GET_BOOL(buf);
		objp->isMandatory = IXDR_GET_BOOL(buf);
		objp->extendableStageDuration_100ms = IXDR_GET_LONG(buf);
		objp->isAddTimeToPredecessor = IXDR_GET_BOOL(buf);
		objp->isAddTimeToFollower = IXDR_GET_BOOL(buf);
		objp->isFixedOrderStage = IXDR_GET_BOOL(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->demandedByPtDirection.demandedByPtDirection_val, (u_int *) &objp->demandedByPtDirection.demandedByPtDirection_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->sgOnDemandList.sgOnDemandList_val, (u_int *) &objp->sgOnDemandList.sgOnDemandList_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->stageSequenceElementNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->stageNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->minDuration_100ms))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->maxDuration_100ms))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isExtendable))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isMandatory))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->extendableStageDuration_100ms))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isAddTimeToPredecessor))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isAddTimeToFollower))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isFixedOrderStage))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->demandedByPtDirection.demandedByPtDirection_val, (u_int *) &objp->demandedByPtDirection.demandedByPtDirection_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->sgOnDemandList.sgOnDemandList_val, (u_int *) &objp->sgOnDemandList.sgOnDemandList_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgStageTransitionSwitchingTime (XDR *xdrs, CfgStageTransitionSwitchingTime *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sgNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->signalIndication))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->time_100ms))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgStageTransition (XDR *xdrs, CfgStageTransition *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 5 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->stageTransitionNo))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isCalculatedWithMinGreen))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->fromStageNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->toStageNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->duration_100ms))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->stageTransitionNo);
		IXDR_PUT_BOOL(buf, objp->isCalculatedWithMinGreen);
		IXDR_PUT_LONG(buf, objp->fromStageNo);
		IXDR_PUT_LONG(buf, objp->toStageNo);
		IXDR_PUT_LONG(buf, objp->duration_100ms);
		}
		 if (!xdr_array (xdrs, (char **)&objp->switchingTimeList.switchingTimeList_val, (u_int *) &objp->switchingTimeList.switchingTimeList_len, ~0,
			sizeof (CfgStageTransitionSwitchingTime), (xdrproc_t) xdr_CfgStageTransitionSwitchingTime))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 5 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->stageTransitionNo))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isCalculatedWithMinGreen))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->fromStageNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->toStageNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->duration_100ms))
				 return FALSE;

		} else {
		objp->stageTransitionNo = IXDR_GET_LONG(buf);
		objp->isCalculatedWithMinGreen = IXDR_GET_BOOL(buf);
		objp->fromStageNo = IXDR_GET_LONG(buf);
		objp->toStageNo = IXDR_GET_LONG(buf);
		objp->duration_100ms = IXDR_GET_LONG(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->switchingTimeList.switchingTimeList_val, (u_int *) &objp->switchingTimeList.switchingTimeList_len, ~0,
			sizeof (CfgStageTransitionSwitchingTime), (xdrproc_t) xdr_CfgStageTransitionSwitchingTime))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->stageTransitionNo))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isCalculatedWithMinGreen))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->fromStageNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->toStageNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->duration_100ms))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->switchingTimeList.switchingTimeList_val, (u_int *) &objp->switchingTimeList.switchingTimeList_len, ~0,
		sizeof (CfgStageTransitionSwitchingTime), (xdrproc_t) xdr_CfgStageTransitionSwitchingTime))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgStageSequencePlan2 (XDR *xdrs, CfgStageSequencePlan2 *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 6 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->splNo))
				 return FALSE;
			 if (!xdr_short (xdrs, &objp->tu_100ms))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->syncStageSequenceElementNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->idleStageSequenceElementNo))
				 return FALSE;
			 if (!xdr_short (xdrs, &objp->gsp_100ms))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isSynchronized))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->splNo);
		IXDR_PUT_SHORT(buf, objp->tu_100ms);
		IXDR_PUT_LONG(buf, objp->syncStageSequenceElementNo);
		IXDR_PUT_LONG(buf, objp->idleStageSequenceElementNo);
		IXDR_PUT_SHORT(buf, objp->gsp_100ms);
		IXDR_PUT_BOOL(buf, objp->isSynchronized);
		}
		 if (!xdr_array (xdrs, (char **)&objp->stageSequences.stageSequences_val, (u_int *) &objp->stageSequences.stageSequences_len, ~0,
			sizeof (CfgStageSequenceElement2), (xdrproc_t) xdr_CfgStageSequenceElement2))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->stageTransitions.stageTransitions_val, (u_int *) &objp->stageTransitions.stageTransitions_len, ~0,
			sizeof (CfgStageTransition), (xdrproc_t) xdr_CfgStageTransition))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->offset_100ms))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->maxExtensionPT_100ms))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->activationRoutineDuration_100ms))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->deactivationRoutineDuration_100ms))
				 return FALSE;
		} else {
			IXDR_PUT_LONG(buf, objp->offset_100ms);
			IXDR_PUT_LONG(buf, objp->maxExtensionPT_100ms);
			IXDR_PUT_LONG(buf, objp->activationRoutineDuration_100ms);
			IXDR_PUT_LONG(buf, objp->deactivationRoutineDuration_100ms);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 6 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->splNo))
				 return FALSE;
			 if (!xdr_short (xdrs, &objp->tu_100ms))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->syncStageSequenceElementNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->idleStageSequenceElementNo))
				 return FALSE;
			 if (!xdr_short (xdrs, &objp->gsp_100ms))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isSynchronized))
				 return FALSE;

		} else {
		objp->splNo = IXDR_GET_LONG(buf);
		objp->tu_100ms = IXDR_GET_SHORT(buf);
		objp->syncStageSequenceElementNo = IXDR_GET_LONG(buf);
		objp->idleStageSequenceElementNo = IXDR_GET_LONG(buf);
		objp->gsp_100ms = IXDR_GET_SHORT(buf);
		objp->isSynchronized = IXDR_GET_BOOL(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->stageSequences.stageSequences_val, (u_int *) &objp->stageSequences.stageSequences_len, ~0,
			sizeof (CfgStageSequenceElement2), (xdrproc_t) xdr_CfgStageSequenceElement2))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->stageTransitions.stageTransitions_val, (u_int *) &objp->stageTransitions.stageTransitions_len, ~0,
			sizeof (CfgStageTransition), (xdrproc_t) xdr_CfgStageTransition))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->offset_100ms))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->maxExtensionPT_100ms))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->activationRoutineDuration_100ms))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->deactivationRoutineDuration_100ms))
				 return FALSE;
		} else {
			objp->offset_100ms = IXDR_GET_LONG(buf);
			objp->maxExtensionPT_100ms = IXDR_GET_LONG(buf);
			objp->activationRoutineDuration_100ms = IXDR_GET_LONG(buf);
			objp->deactivationRoutineDuration_100ms = IXDR_GET_LONG(buf);
		}
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->splNo))
		 return FALSE;
	 if (!xdr_short (xdrs, &objp->tu_100ms))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->syncStageSequenceElementNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->idleStageSequenceElementNo))
		 return FALSE;
	 if (!xdr_short (xdrs, &objp->gsp_100ms))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isSynchronized))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->stageSequences.stageSequences_val, (u_int *) &objp->stageSequences.stageSequences_len, ~0,
		sizeof (CfgStageSequenceElement2), (xdrproc_t) xdr_CfgStageSequenceElement2))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->stageTransitions.stageTransitions_val, (u_int *) &objp->stageTransitions.stageTransitions_len, ~0,
		sizeof (CfgStageTransition), (xdrproc_t) xdr_CfgStageTransition))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->offset_100ms))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->maxExtensionPT_100ms))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->activationRoutineDuration_100ms))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->deactivationRoutineDuration_100ms))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgSignalplanInfoCCtrl (XDR *xdrs, CfgSignalplanInfoCCtrl *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_int (xdrs, &objp->splNo))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->name, ~0))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 6 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_short (xdrs, &objp->tu_100ms))
				 return FALSE;
			 if (!xdr_short (xdrs, &objp->gsp_100ms))
				 return FALSE;
			 if (!xdr_short (xdrs, &objp->offset_100ms))
				 return FALSE;
			 if (!xdr_short (xdrs, &objp->activationPointOfTime_100ms))
				 return FALSE;
			 if (!xdr_short (xdrs, &objp->deactivationPointOfTime_100ms))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->itRef))
				 return FALSE;

		} else {
		IXDR_PUT_SHORT(buf, objp->tu_100ms);
		IXDR_PUT_SHORT(buf, objp->gsp_100ms);
		IXDR_PUT_SHORT(buf, objp->offset_100ms);
		IXDR_PUT_SHORT(buf, objp->activationPointOfTime_100ms);
		IXDR_PUT_SHORT(buf, objp->deactivationPointOfTime_100ms);
		IXDR_PUT_LONG(buf, objp->itRef);
		}
		 if (!xdr_array (xdrs, (char **)&objp->minGreenRefs.minGreenRefs_val, (u_int *) &objp->minGreenRefs.minGreenRefs_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->minRedRefs.minRedRefs_val, (u_int *) &objp->minRedRefs.minRedRefs_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->transGnRdRefs.transGnRdRefs_val, (u_int *) &objp->transGnRdRefs.transGnRdRefs_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->transRdGnRefs.transRdGnRefs_val, (u_int *) &objp->transRdGnRefs.transRdGnRefs_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->switchingTimeList.switchingTimeList_val, (u_int *) &objp->switchingTimeList.switchingTimeList_len, ~0,
			sizeof (CfgStageTransitionSwitchingTime), (xdrproc_t) xdr_CfgStageTransitionSwitchingTime))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_int (xdrs, &objp->splNo))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->name, ~0))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 6 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_short (xdrs, &objp->tu_100ms))
				 return FALSE;
			 if (!xdr_short (xdrs, &objp->gsp_100ms))
				 return FALSE;
			 if (!xdr_short (xdrs, &objp->offset_100ms))
				 return FALSE;
			 if (!xdr_short (xdrs, &objp->activationPointOfTime_100ms))
				 return FALSE;
			 if (!xdr_short (xdrs, &objp->deactivationPointOfTime_100ms))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->itRef))
				 return FALSE;

		} else {
		objp->tu_100ms = IXDR_GET_SHORT(buf);
		objp->gsp_100ms = IXDR_GET_SHORT(buf);
		objp->offset_100ms = IXDR_GET_SHORT(buf);
		objp->activationPointOfTime_100ms = IXDR_GET_SHORT(buf);
		objp->deactivationPointOfTime_100ms = IXDR_GET_SHORT(buf);
		objp->itRef = IXDR_GET_LONG(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->minGreenRefs.minGreenRefs_val, (u_int *) &objp->minGreenRefs.minGreenRefs_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->minRedRefs.minRedRefs_val, (u_int *) &objp->minRedRefs.minRedRefs_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->transGnRdRefs.transGnRdRefs_val, (u_int *) &objp->transGnRdRefs.transGnRdRefs_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->transRdGnRefs.transRdGnRefs_val, (u_int *) &objp->transRdGnRefs.transRdGnRefs_len, ~0,
			sizeof (int), (xdrproc_t) xdr_int))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->switchingTimeList.switchingTimeList_val, (u_int *) &objp->switchingTimeList.switchingTimeList_len, ~0,
			sizeof (CfgStageTransitionSwitchingTime), (xdrproc_t) xdr_CfgStageTransitionSwitchingTime))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->splNo))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->name, ~0))
		 return FALSE;
	 if (!xdr_short (xdrs, &objp->tu_100ms))
		 return FALSE;
	 if (!xdr_short (xdrs, &objp->gsp_100ms))
		 return FALSE;
	 if (!xdr_short (xdrs, &objp->offset_100ms))
		 return FALSE;
	 if (!xdr_short (xdrs, &objp->activationPointOfTime_100ms))
		 return FALSE;
	 if (!xdr_short (xdrs, &objp->deactivationPointOfTime_100ms))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->itRef))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->minGreenRefs.minGreenRefs_val, (u_int *) &objp->minGreenRefs.minGreenRefs_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->minRedRefs.minRedRefs_val, (u_int *) &objp->minRedRefs.minRedRefs_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->transGnRdRefs.transGnRdRefs_val, (u_int *) &objp->transGnRdRefs.transGnRdRefs_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->transRdGnRefs.transRdGnRefs_val, (u_int *) &objp->transRdGnRefs.transRdGnRefs_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->switchingTimeList.switchingTimeList_val, (u_int *) &objp->switchingTimeList.switchingTimeList_len, ~0,
		sizeof (CfgStageTransitionSwitchingTime), (xdrproc_t) xdr_CfgStageTransitionSwitchingTime))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ReCalculationMethodCctrl (XDR *xdrs, ReCalculationMethodCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_SyncMethodCctrl (XDR *xdrs, SyncMethodCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgSyncInfoCctrl (XDR *xdrs, CfgSyncInfoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_ReCalculationMethodCctrl (xdrs, &objp->reCalculationMethod))
		 return FALSE;
	 if (!xdr_SyncMethodCctrl (xdrs, &objp->syncMethod))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->syncCyclesAllowed))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->globalRefTimeShift_100ms))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgInterGreenTimeElementCctrl (XDR *xdrs, CfgInterGreenTimeElementCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->enteringSgNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->clearingSgNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->value))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgInterGreenTimeTableCctrl (XDR *xdrs, CfgInterGreenTimeTableCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->igTableNo))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->elements.elements_val, (u_int *) &objp->elements.elements_len, ~0,
		sizeof (CfgInterGreenTimeElementCctrl), (xdrproc_t) xdr_CfgInterGreenTimeElementCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgSelector (XDR *xdrs, CfgSelector *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgInfoBaseCctrl (XDR *xdrs, CfgInfoBaseCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->no))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->shortname, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->name, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgInfoConnection (XDR *xdrs, CfgInfoConnection *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->communicationType, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->controlPrinciple, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgInfoDetectorCctrl (XDR *xdrs, CfgInfoDetectorCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_CfgInfoBaseCctrl (xdrs, &objp->cfgInfoBaseDet))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->channelNo))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->modelType, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgDetectorParamCctrl (XDR *xdrs, CfgDetectorParamCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_CfgInfoDetectorCctrl (xdrs, &objp->base))
		 return FALSE;
	 if (!xdr_float (xdrs, &objp->SmothingFactorUp))
		 return FALSE;
	 if (!xdr_float (xdrs, &objp->SmothingFactorDown))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->Mexwainterval))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgIntersectionControllerTypeCctrl (XDR *xdrs, CfgIntersectionControllerTypeCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgGeneralParamCctrl (XDR *xdrs, CfgGeneralParamCctrl *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_CfgIntersectionControllerTypeCctrl (xdrs, &objp->controllerType))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->name, 32))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->tccNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->guiNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->fnr))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->systemPulse_ms))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->tccNo);
		IXDR_PUT_LONG(buf, objp->guiNo);
		IXDR_PUT_LONG(buf, objp->fnr);
		IXDR_PUT_LONG(buf, objp->systemPulse_ms);
		}
		 if (!xdr_string (xdrs, &objp->centerType, 16))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_CfgIntersectionControllerTypeCctrl (xdrs, &objp->controllerType))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->name, 32))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->tccNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->guiNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->fnr))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->systemPulse_ms))
				 return FALSE;

		} else {
		objp->tccNo = IXDR_GET_LONG(buf);
		objp->guiNo = IXDR_GET_LONG(buf);
		objp->fnr = IXDR_GET_LONG(buf);
		objp->systemPulse_ms = IXDR_GET_LONG(buf);
		}
		 if (!xdr_string (xdrs, &objp->centerType, 16))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_CfgIntersectionControllerTypeCctrl (xdrs, &objp->controllerType))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->name, 32))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->tccNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->guiNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->fnr))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->systemPulse_ms))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->centerType, 16))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_SelectedConfig (XDR *xdrs, SelectedConfig *objp)
{
	register int32_t *buf;

	 if (!xdr_CfgSelector (xdrs, &objp->selector))
		 return FALSE;
	switch (objp->selector) {
	case CS_CfgSgInfo:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedConfig_u.sgInfos.sgInfos_val, (u_int *) &objp->SelectedConfig_u.sgInfos.sgInfos_len, ~0,
			sizeof (CfgSgInfo), (xdrproc_t) xdr_CfgSgInfo))
			 return FALSE;
		break;
	case CS_CfgSgDetParam:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedConfig_u.sgDetParams.sgDetParams_val, (u_int *) &objp->SelectedConfig_u.sgDetParams.sgDetParams_len, ~0,
			sizeof (CfgSgDetParam), (xdrproc_t) xdr_CfgSgDetParam))
			 return FALSE;
		break;
	case CS_CfgStages:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedConfig_u.stages.stages_val, (u_int *) &objp->SelectedConfig_u.stages.stages_len, ~0,
			sizeof (CfgStage), (xdrproc_t) xdr_CfgStage))
			 return FALSE;
		break;
	case CS_CfgStageSequencePlan2:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedConfig_u.stageSequencePlans2.stageSequencePlans2_val, (u_int *) &objp->SelectedConfig_u.stageSequencePlans2.stageSequencePlans2_len, ~0,
			sizeof (CfgStageSequencePlan2), (xdrproc_t) xdr_CfgStageSequencePlan2))
			 return FALSE;
		break;
	case CS_CfgSystem_pulse_ms:
		 if (!xdr_int (xdrs, &objp->SelectedConfig_u.systemPulseMs))
			 return FALSE;
		break;
	case CS_CfgSyncInfoCctrl:
		 if (!xdr_CfgSyncInfoCctrl (xdrs, &objp->SelectedConfig_u.syncInfo))
			 return FALSE;
		break;
	case CS_CfgInterGreenTimeTables:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedConfig_u.igTables.igTables_val, (u_int *) &objp->SelectedConfig_u.igTables.igTables_len, ~0,
			sizeof (CfgInterGreenTimeTableCctrl), (xdrproc_t) xdr_CfgInterGreenTimeTableCctrl))
			 return FALSE;
		break;
	case CS_CfgSgInfo2CCtrl:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedConfig_u.sgInfos2.sgInfos2_val, (u_int *) &objp->SelectedConfig_u.sgInfos2.sgInfos2_len, ~0,
			sizeof (CfgSgInfo2CCtrl), (xdrproc_t) xdr_CfgSgInfo2CCtrl))
			 return FALSE;
		break;
	case CS_CfgSignalplanInfoCCtrl:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedConfig_u.signalplanInfos.signalplanInfos_val, (u_int *) &objp->SelectedConfig_u.signalplanInfos.signalplanInfos_len, ~0,
			sizeof (CfgSignalplanInfoCCtrl), (xdrproc_t) xdr_CfgSignalplanInfoCCtrl))
			 return FALSE;
		break;
	case CS_CfgDetectorParamCctrl:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedConfig_u.detectorParams.detectorParams_val, (u_int *) &objp->SelectedConfig_u.detectorParams.detectorParams_len, ~0,
			sizeof (CfgDetectorParamCctrl), (xdrproc_t) xdr_CfgDetectorParamCctrl))
			 return FALSE;
		break;
	case CS_CfgGeneralParamCctrl:
		 if (!xdr_CfgGeneralParamCctrl (xdrs, &objp->SelectedConfig_u.generalParams))
			 return FALSE;
		break;
	case CS_CfgError:
		 if (!xdr_RetCodeCctrl (xdrs, &objp->SelectedConfig_u.ret))
			 return FALSE;
		break;
	default:
		 if (!xdr_RetCodeCctrl (xdrs, &objp->SelectedConfig_u.ret1))
			 return FALSE;
		break;
	}
	return TRUE;
}

bool_t
xdr_SgHeadColorCctrl (XDR *xdrs, SgHeadColorCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->color, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgInfoSignalHeadCctrl (XDR *xdrs, CfgInfoSignalHeadCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_CfgInfoBaseCctrl (xdrs, &objp->cfgInfoBaseSignalHead))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->chamberColors.chamberColors_val, (u_int *) &objp->chamberColors.chamberColors_len, ~0,
		sizeof (SgHeadColorCctrl), (xdrproc_t) xdr_SgHeadColorCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgInfoSignalGroupCctrl (XDR *xdrs, CfgInfoSignalGroupCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_CfgInfoBaseCctrl (xdrs, &objp->cfgInfoBaseSignalGroup))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->sgType, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->sgDetailType, ~0))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->cfgInfoSignalHead.cfgInfoSignalHead_val, (u_int *) &objp->cfgInfoSignalHead.cfgInfoSignalHead_len, ~0,
		sizeof (CfgInfoSignalHeadCctrl), (xdrproc_t) xdr_CfgInfoSignalHeadCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgInfoSignalPlanCctrl (XDR *xdrs, CfgInfoSignalPlanCctrl *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_CfgInfoBaseCctrl (xdrs, &objp->cfgInfoBaseSignalPlan))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->tu))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->gsp))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->cycleTimeMonitorThreshold_100ms))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isSynchronized))
				 return FALSE;
		} else {
			IXDR_PUT_LONG(buf, objp->tu);
			IXDR_PUT_LONG(buf, objp->gsp);
			IXDR_PUT_LONG(buf, objp->cycleTimeMonitorThreshold_100ms);
			IXDR_PUT_BOOL(buf, objp->isSynchronized);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_CfgInfoBaseCctrl (xdrs, &objp->cfgInfoBaseSignalPlan))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->tu))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->gsp))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->cycleTimeMonitorThreshold_100ms))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->isSynchronized))
				 return FALSE;
		} else {
			objp->tu = IXDR_GET_LONG(buf);
			objp->gsp = IXDR_GET_LONG(buf);
			objp->cycleTimeMonitorThreshold_100ms = IXDR_GET_LONG(buf);
			objp->isSynchronized = IXDR_GET_BOOL(buf);
		}
	 return TRUE;
	}

	 if (!xdr_CfgInfoBaseCctrl (xdrs, &objp->cfgInfoBaseSignalPlan))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->tu))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->gsp))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->cycleTimeMonitorThreshold_100ms))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isSynchronized))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CfgInfoSelector (XDR *xdrs, CfgInfoSelector *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_SelectedCfgInfo (XDR *xdrs, SelectedCfgInfo *objp)
{
	register int32_t *buf;

	 if (!xdr_CfgInfoSelector (xdrs, &objp->selector))
		 return FALSE;
	switch (objp->selector) {
	case CS_CfgInfoIntersection:
		 if (!xdr_CfgInfoBaseCctrl (xdrs, &objp->SelectedCfgInfo_u.infoIntersection))
			 return FALSE;
		break;
	case CS_CfgInfoPartialIntersections:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedCfgInfo_u.partialIntersections.partialIntersections_val, (u_int *) &objp->SelectedCfgInfo_u.partialIntersections.partialIntersections_len, ~0,
			sizeof (CfgInfoBaseCctrl), (xdrproc_t) xdr_CfgInfoBaseCctrl))
			 return FALSE;
		break;
	case CS_CfgInfoSignalingGroups:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedCfgInfo_u.signalingGroups.signalingGroups_val, (u_int *) &objp->SelectedCfgInfo_u.signalingGroups.signalingGroups_len, ~0,
			sizeof (CfgInfoBaseCctrl), (xdrproc_t) xdr_CfgInfoBaseCctrl))
			 return FALSE;
		break;
	case CS_CfgInfoSignalPlans:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedCfgInfo_u.signalPlans.signalPlans_val, (u_int *) &objp->SelectedCfgInfo_u.signalPlans.signalPlans_len, ~0,
			sizeof (CfgInfoBaseCctrl), (xdrproc_t) xdr_CfgInfoBaseCctrl))
			 return FALSE;
		break;
	case CS_CfgInfoDetectors:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedCfgInfo_u.cfgDetectors.cfgDetectors_val, (u_int *) &objp->SelectedCfgInfo_u.cfgDetectors.cfgDetectors_len, ~0,
			sizeof (CfgInfoBaseCctrl), (xdrproc_t) xdr_CfgInfoBaseCctrl))
			 return FALSE;
		break;
	case CS_CfgInfoSubsystem:
		 if (!xdr_CfgInfoBaseCctrl (xdrs, &objp->SelectedCfgInfo_u.cfgSubs))
			 return FALSE;
		break;
	case CS_CfgInfoConnection:
		 if (!xdr_CfgInfoConnection (xdrs, &objp->SelectedCfgInfo_u.cfgCon))
			 return FALSE;
		break;
	case CS_CfgInfoSGCctrl:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedCfgInfo_u.cfgSignalGroups.cfgSignalGroups_val, (u_int *) &objp->SelectedCfgInfo_u.cfgSignalGroups.cfgSignalGroups_len, ~0,
			sizeof (CfgInfoSignalGroupCctrl), (xdrproc_t) xdr_CfgInfoSignalGroupCctrl))
			 return FALSE;
		break;
	case CS_CfgInfoSPCctrl:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedCfgInfo_u.cfgSignalPlans.cfgSignalPlans_val, (u_int *) &objp->SelectedCfgInfo_u.cfgSignalPlans.cfgSignalPlans_len, ~0,
			sizeof (CfgInfoSignalPlanCctrl), (xdrproc_t) xdr_CfgInfoSignalPlanCctrl))
			 return FALSE;
		break;
	case CS_CfgInfoDetCctrl:
		 if (!xdr_array (xdrs, (char **)&objp->SelectedCfgInfo_u.cfgDets.cfgDets_val, (u_int *) &objp->SelectedCfgInfo_u.cfgDets.cfgDets_len, ~0,
			sizeof (CfgInfoDetectorCctrl), (xdrproc_t) xdr_CfgInfoDetectorCctrl))
			 return FALSE;
		break;
	case CS_CfgInfoError:
		 if (!xdr_RetCodeCctrl (xdrs, &objp->SelectedCfgInfo_u.ret))
			 return FALSE;
		break;
	default:
		 if (!xdr_RetCodeCctrl (xdrs, &objp->SelectedCfgInfo_u.ret1))
			 return FALSE;
		break;
	}
	return TRUE;
}

bool_t
xdr_OitdCctrl (XDR *xdrs, OitdCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->member))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->otype))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->index))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_OitdCctrlA (XDR *xdrs, OitdCctrlA *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->OitdCctrlA_val, (u_int *) &objp->OitdCctrlA_len, ~0,
		sizeof (OitdCctrl), (xdrproc_t) xdr_OitdCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DeviceValueCctrl (XDR *xdrs, DeviceValueCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_OitdCctrl (xdrs, &objp->oitd))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->tickTime))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->value))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DeviceValuesCctrl (XDR *xdrs, DeviceValuesCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_quad_t (xdrs, &objp->timestamp))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->dv.dv_val, (u_int *) &objp->dv.dv_len, ~0,
		sizeof (DeviceValueCctrl), (xdrproc_t) xdr_DeviceValueCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NlsElementCctrl (XDR *xdrs, NlsElementCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->key, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->value, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NlsMappingCctrl (XDR *xdrs, NlsMappingCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->lang, 2))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->map.map_val, (u_int *) &objp->map.map_len, ~0,
		sizeof (NlsElementCctrl), (xdrproc_t) xdr_NlsElementCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_NlsMappingsCctrl (XDR *xdrs, NlsMappingsCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->NlsMappingsCctrl_val, (u_int *) &objp->NlsMappingsCctrl_len, ~0,
		sizeof (NlsMappingCctrl), (xdrproc_t) xdr_NlsMappingCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DeviceValueIndexType (XDR *xdrs, DeviceValueIndexType *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DeviceValueTypeCctrl (XDR *xdrs, DeviceValueTypeCctrl *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_string (xdrs, &objp->name, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->longName, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->description, ~0))
			 return FALSE;
		 if (!xdr_int (xdrs, &objp->member))
			 return FALSE;
		 if (!xdr_int (xdrs, &objp->otype))
			 return FALSE;
		 if (!xdr_DeviceValueIndexType (xdrs, &objp->dvit))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->minIndex))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->maxIndex))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->minValue))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->maxValue))
				 return FALSE;
		} else {
			IXDR_PUT_LONG(buf, objp->minIndex);
			IXDR_PUT_LONG(buf, objp->maxIndex);
			IXDR_PUT_LONG(buf, objp->minValue);
			IXDR_PUT_LONG(buf, objp->maxValue);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_string (xdrs, &objp->name, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->longName, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->description, ~0))
			 return FALSE;
		 if (!xdr_int (xdrs, &objp->member))
			 return FALSE;
		 if (!xdr_int (xdrs, &objp->otype))
			 return FALSE;
		 if (!xdr_DeviceValueIndexType (xdrs, &objp->dvit))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->minIndex))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->maxIndex))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->minValue))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->maxValue))
				 return FALSE;
		} else {
			objp->minIndex = IXDR_GET_LONG(buf);
			objp->maxIndex = IXDR_GET_LONG(buf);
			objp->minValue = IXDR_GET_LONG(buf);
			objp->maxValue = IXDR_GET_LONG(buf);
		}
	 return TRUE;
	}

	 if (!xdr_string (xdrs, &objp->name, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->longName, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->description, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->member))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->otype))
		 return FALSE;
	 if (!xdr_DeviceValueIndexType (xdrs, &objp->dvit))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->minIndex))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->maxIndex))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->minValue))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->maxValue))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DeviceValuesUsedIndicesCctrl (XDR *xdrs, DeviceValuesUsedIndicesCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->DeviceValuesUsedIndicesCctrl_val, (u_int *) &objp->DeviceValuesUsedIndicesCctrl_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DeviceValuesMetaDataCctrl (XDR *xdrs, DeviceValuesMetaDataCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_UnitId (xdrs, &objp->providerType))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->name, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->vers, ~0))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->dvt.dvt_val, (u_int *) &objp->dvt.dvt_len, ~0,
		sizeof (DeviceValueTypeCctrl), (xdrproc_t) xdr_DeviceValueTypeCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DeviceValuesMetaDataCctrlA (XDR *xdrs, DeviceValuesMetaDataCctrlA *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->DeviceValuesMetaDataCctrlA_val, (u_int *) &objp->DeviceValuesMetaDataCctrlA_len, ~0,
		sizeof (DeviceValuesMetaDataCctrl), (xdrproc_t) xdr_DeviceValuesMetaDataCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CantoNetConfigDtoCctrl (XDR *xdrs, CantoNetConfigDtoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->profileType, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->profileDetails, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->upstreamSpeed))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->downstreamSpeed))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->vpnGateway, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->vpnPortNumber))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->vpnProtocol, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CantoNetConfigCctrl (XDR *xdrs, CantoNetConfigCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_RetCodeCctrl (xdrs, &objp->retCode))
		 return FALSE;
	switch (objp->retCode) {
	case RC_OK:
		 if (!xdr_CantoNetConfigDtoCctrl (xdrs, &objp->CantoNetConfigCctrl_u.cantoNetConfig))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_MkjtricActuationVersionCctrl (XDR *xdrs, MkjtricActuationVersionCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->taName, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->taVersion, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_VersionsDtoCctrl (XDR *xdrs, VersionsDtoCctrl *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_string (xdrs, &objp->type, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->customerName, ~0))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->configVersion))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->planningVersion))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->configBuildNo))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->configVersion);
		IXDR_PUT_LONG(buf, objp->planningVersion);
		IXDR_PUT_LONG(buf, objp->configBuildNo);
		}
		 if (!xdr_string (xdrs, &objp->fwVersion, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->cbcVersion, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->chxVersion, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->cmuVersion, ~0))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->taVersions.taVersions_val, (u_int *) &objp->taVersions.taVersions_len, ~0,
			sizeof (MkjtricActuationVersionCctrl), (xdrproc_t) xdr_MkjtricActuationVersionCctrl))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_string (xdrs, &objp->type, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->customerName, ~0))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->configVersion))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->planningVersion))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->configBuildNo))
				 return FALSE;

		} else {
		objp->configVersion = IXDR_GET_LONG(buf);
		objp->planningVersion = IXDR_GET_LONG(buf);
		objp->configBuildNo = IXDR_GET_LONG(buf);
		}
		 if (!xdr_string (xdrs, &objp->fwVersion, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->cbcVersion, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->chxVersion, ~0))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->cmuVersion, ~0))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->taVersions.taVersions_val, (u_int *) &objp->taVersions.taVersions_len, ~0,
			sizeof (MkjtricActuationVersionCctrl), (xdrproc_t) xdr_MkjtricActuationVersionCctrl))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_string (xdrs, &objp->type, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->customerName, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->configVersion))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->planningVersion))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->configBuildNo))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->fwVersion, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->cbcVersion, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->chxVersion, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->cmuVersion, ~0))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->taVersions.taVersions_val, (u_int *) &objp->taVersions.taVersions_len, ~0,
		sizeof (MkjtricActuationVersionCctrl), (xdrproc_t) xdr_MkjtricActuationVersionCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_VersionsCctrl (XDR *xdrs, VersionsCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_RetCodeCctrl (xdrs, &objp->retCode))
		 return FALSE;
	switch (objp->retCode) {
	case RC_OK:
		 if (!xdr_VersionsDtoCctrl (xdrs, &objp->VersionsCctrl_u.dto))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ProcessControl (XDR *xdrs, ProcessControl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ArchiveSelectorCctrl (XDR *xdrs, ArchiveSelectorCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ArchiveKeysCctrl (XDR *xdrs, ArchiveKeysCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_quad_t (xdrs, &objp->timeStamp))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->tickTimeOfLastChange))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->primaryKey))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ActualStatusDtoCctrl (XDR *xdrs, ActualStatusDtoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
		 return FALSE;
	 if (!xdr_ActualStatusCctrl (xdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_StandardMessageDtoCctrl (XDR *xdrs, StandardMessageDtoCctrl *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->transactionNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->member))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->otype))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->severity))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->transactionNo);
		IXDR_PUT_LONG(buf, objp->member);
		IXDR_PUT_LONG(buf, objp->otype);
		IXDR_PUT_LONG(buf, objp->severity);
		}
		 if (!xdr_string (xdrs, &objp->name, ~0))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->parameters.parameters_val, (u_int *) &objp->parameters.parameters_len, ~0,
			sizeof (MsgParameterCctrl), (xdrproc_t) xdr_MsgParameterCctrl))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->transactionNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->member))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->otype))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->severity))
				 return FALSE;

		} else {
		objp->transactionNo = IXDR_GET_LONG(buf);
		objp->member = IXDR_GET_LONG(buf);
		objp->otype = IXDR_GET_LONG(buf);
		objp->severity = IXDR_GET_LONG(buf);
		}
		 if (!xdr_string (xdrs, &objp->name, ~0))
			 return FALSE;
		 if (!xdr_array (xdrs, (char **)&objp->parameters.parameters_val, (u_int *) &objp->parameters.parameters_len, ~0,
			sizeof (MsgParameterCctrl), (xdrproc_t) xdr_MsgParameterCctrl))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->transactionNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->member))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->otype))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->severity))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->name, ~0))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->parameters.parameters_val, (u_int *) &objp->parameters.parameters_len, ~0,
		sizeof (MsgParameterCctrl), (xdrproc_t) xdr_MsgParameterCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DeviceValuesDtoCctrl (XDR *xdrs, DeviceValuesDtoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->dv.dv_val, (u_int *) &objp->dv.dv_len, ~0,
		sizeof (DeviceValueCctrl), (xdrproc_t) xdr_DeviceValueCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_SignalIndicationsDtoCctrl (XDR *xdrs, SignalIndicationsDtoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
		 return FALSE;
	 if (!xdr_SignalIndicationsCctrl (xdrs, &objp->signalIndications))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DetectorValuesDtoCctrl (XDR *xdrs, DetectorValuesDtoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->detectorValues.detectorValues_val, (u_int *) &objp->detectorValues.detectorValues_len, ~0,
		sizeof (DetRawValuesGradedCctrl), (xdrproc_t) xdr_DetRawValuesGradedCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DetectorAggregationDtoCctrl (XDR *xdrs, DetectorAggregationDtoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->cycleLength))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->isFixedCycle))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->aggregationEntries.aggregationEntries_val, (u_int *) &objp->aggregationEntries.aggregationEntries_len, ~0,
		sizeof (DetectorAggregationCctrl), (xdrproc_t) xdr_DetectorAggregationCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_LampStatesDtoCctrl (XDR *xdrs, LampStatesDtoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->lampStates.lampStates_val, (u_int *) &objp->lampStates.lampStates_len, ~0,
		sizeof (LampStatusCctrl), (xdrproc_t) xdr_LampStatusCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_DetectorStatesDtoCctrl (XDR *xdrs, DetectorStatesDtoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->detectorStates.detectorStates_val, (u_int *) &objp->detectorStates.detectorStates_len, ~0,
		sizeof (DetStatusCctrl), (xdrproc_t) xdr_DetStatusCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CommonStatesDtoCctrl (XDR *xdrs, CommonStatesDtoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->commonStates.commonStates_val, (u_int *) &objp->commonStates.commonStates_len, ~0,
		sizeof (CommonStatusCctrl), (xdrproc_t) xdr_CommonStatusCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_R09AttrSelCctrl (XDR *xdrs, R09AttrSelCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_R09AttributeCctrl (XDR *xdrs, R09AttributeCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_R09AttrSelCctrl (xdrs, &objp->selector))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->value))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RideEventSourceCctrl (XDR *xdrs, RideEventSourceCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RideEventCctrl (XDR *xdrs, RideEventCctrl *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_RideEventSourceCctrl (xdrs, &objp->source))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->rpNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->lineNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->runNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->destinationNo))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->rpNo);
		IXDR_PUT_LONG(buf, objp->lineNo);
		IXDR_PUT_LONG(buf, objp->runNo);
		IXDR_PUT_LONG(buf, objp->destinationNo);
		}
		 if (!xdr_array (xdrs, (char **)&objp->attrs.attrs_val, (u_int *) &objp->attrs.attrs_len, ~0,
			sizeof (R09AttributeCctrl), (xdrproc_t) xdr_R09AttributeCctrl))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_RideEventSourceCctrl (xdrs, &objp->source))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->rpNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->lineNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->runNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->destinationNo))
				 return FALSE;

		} else {
		objp->rpNo = IXDR_GET_LONG(buf);
		objp->lineNo = IXDR_GET_LONG(buf);
		objp->runNo = IXDR_GET_LONG(buf);
		objp->destinationNo = IXDR_GET_LONG(buf);
		}
		 if (!xdr_array (xdrs, (char **)&objp->attrs.attrs_val, (u_int *) &objp->attrs.attrs_len, ~0,
			sizeof (R09AttributeCctrl), (xdrproc_t) xdr_R09AttributeCctrl))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_RideEventSourceCctrl (xdrs, &objp->source))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->rpNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->lineNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->runNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->destinationNo))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->attrs.attrs_val, (u_int *) &objp->attrs.attrs_len, ~0,
		sizeof (R09AttributeCctrl), (xdrproc_t) xdr_R09AttributeCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_AmliEventTypeCctrl (XDR *xdrs, AmliEventTypeCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_AmliCheckOutTypeCctrl (XDR *xdrs, AmliCheckOutTypeCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_AmliDtoCctrl (XDR *xdrs, AmliDtoCctrl *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
			 return FALSE;
		 if (!xdr_RideEventCctrl (xdrs, &objp->event))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 11 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->greenTime))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->ptModActive))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->tx))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->spNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->actStage))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->nextStage))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->travelTime))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->txGNS))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->txGNE))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->amliTimeout))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->ptDirNo))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->greenTime);
		IXDR_PUT_BOOL(buf, objp->ptModActive);
		IXDR_PUT_LONG(buf, objp->tx);
		IXDR_PUT_LONG(buf, objp->spNo);
		IXDR_PUT_LONG(buf, objp->actStage);
		IXDR_PUT_LONG(buf, objp->nextStage);
		IXDR_PUT_LONG(buf, objp->travelTime);
		IXDR_PUT_LONG(buf, objp->txGNS);
		IXDR_PUT_LONG(buf, objp->txGNE);
		IXDR_PUT_LONG(buf, objp->amliTimeout);
		IXDR_PUT_LONG(buf, objp->ptDirNo);
		}
		 if (!xdr_AmliEventTypeCctrl (xdrs, &objp->type))
			 return FALSE;
		 if (!xdr_AmliCheckOutTypeCctrl (xdrs, &objp->coType))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
			 return FALSE;
		 if (!xdr_RideEventCctrl (xdrs, &objp->event))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 11 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->greenTime))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->ptModActive))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->tx))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->spNo))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->actStage))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->nextStage))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->travelTime))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->txGNS))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->txGNE))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->amliTimeout))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->ptDirNo))
				 return FALSE;

		} else {
		objp->greenTime = IXDR_GET_LONG(buf);
		objp->ptModActive = IXDR_GET_BOOL(buf);
		objp->tx = IXDR_GET_LONG(buf);
		objp->spNo = IXDR_GET_LONG(buf);
		objp->actStage = IXDR_GET_LONG(buf);
		objp->nextStage = IXDR_GET_LONG(buf);
		objp->travelTime = IXDR_GET_LONG(buf);
		objp->txGNS = IXDR_GET_LONG(buf);
		objp->txGNE = IXDR_GET_LONG(buf);
		objp->amliTimeout = IXDR_GET_LONG(buf);
		objp->ptDirNo = IXDR_GET_LONG(buf);
		}
		 if (!xdr_AmliEventTypeCctrl (xdrs, &objp->type))
			 return FALSE;
		 if (!xdr_AmliCheckOutTypeCctrl (xdrs, &objp->coType))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_ArchiveKeysCctrl (xdrs, &objp->keys))
		 return FALSE;
	 if (!xdr_RideEventCctrl (xdrs, &objp->event))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->greenTime))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->ptModActive))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->tx))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->spNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->actStage))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->nextStage))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->travelTime))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->txGNS))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->txGNE))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->amliTimeout))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->ptDirNo))
		 return FALSE;
	 if (!xdr_AmliEventTypeCctrl (xdrs, &objp->type))
		 return FALSE;
	 if (!xdr_AmliCheckOutTypeCctrl (xdrs, &objp->coType))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ArchiveDtoCctrl (XDR *xdrs, ArchiveDtoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_ArchiveSelectorCctrl (xdrs, &objp->selector))
		 return FALSE;
	switch (objp->selector) {
	case AS_ActualStatus:
		 if (!xdr_ActualStatusDtoCctrl (xdrs, &objp->ArchiveDtoCctrl_u.asDto))
			 return FALSE;
		break;
	case AS_StandardMessage:
		 if (!xdr_StandardMessageDtoCctrl (xdrs, &objp->ArchiveDtoCctrl_u.smDto))
			 return FALSE;
		break;
	case AS_CommonStates:
		 if (!xdr_CommonStatesDtoCctrl (xdrs, &objp->ArchiveDtoCctrl_u.csDto))
			 return FALSE;
		break;
	case AS_LampStates:
		 if (!xdr_LampStatesDtoCctrl (xdrs, &objp->ArchiveDtoCctrl_u.lsDto))
			 return FALSE;
		break;
	case AS_DetectorStates:
		 if (!xdr_DetectorStatesDtoCctrl (xdrs, &objp->ArchiveDtoCctrl_u.dsDto))
			 return FALSE;
		break;
	case AS_DetectorValues:
		 if (!xdr_DetectorValuesDtoCctrl (xdrs, &objp->ArchiveDtoCctrl_u.dvDto))
			 return FALSE;
		break;
	case AS_SignalIndications:
		 if (!xdr_SignalIndicationsDtoCctrl (xdrs, &objp->ArchiveDtoCctrl_u.siDto))
			 return FALSE;
		break;
	case AS_DeviceValues:
		 if (!xdr_DeviceValuesDtoCctrl (xdrs, &objp->ArchiveDtoCctrl_u.devVDto))
			 return FALSE;
		break;
	case AS_DetectorAggregation:
		 if (!xdr_DetectorAggregationDtoCctrl (xdrs, &objp->ArchiveDtoCctrl_u.daDto))
			 return FALSE;
		break;
	case AS_Amli:
		 if (!xdr_AmliDtoCctrl (xdrs, &objp->ArchiveDtoCctrl_u.amDto))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ArchiveResultCctrl (XDR *xdrs, ArchiveResultCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_RetCodeCctrl (xdrs, &objp->retCode))
		 return FALSE;
	switch (objp->retCode) {
	case RC_OK:
		 if (!xdr_ArchiveDtoCctrl (xdrs, &objp->ArchiveResultCctrl_u.dto))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ArchiveResultArrayCctrl (XDR *xdrs, ArchiveResultArrayCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_RetCodeCctrl (xdrs, &objp->retCode))
		 return FALSE;
	switch (objp->retCode) {
	case RC_OK:
		 if (!xdr_array (xdrs, (char **)&objp->ArchiveResultArrayCctrl_u.dtos.dtos_val, (u_int *) &objp->ArchiveResultArrayCctrl_u.dtos.dtos_len, ~0,
			sizeof (ArchiveDtoCctrl), (xdrproc_t) xdr_ArchiveDtoCctrl))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ArchiveSubscribeInfoCctrl (XDR *xdrs, ArchiveSubscribeInfoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_ArchiveSelectorCctrl (xdrs, &objp->selector))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TdtSubscriptionInfoCctrl (XDR *xdrs, TdtSubscriptionInfoCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_MkjtricDataTypeCctrl (xdrs, &objp->tdt))
		 return FALSE;
	switch (objp->tdt) {
	case TDT_ARCHIVEEVENTS:
		 if (!xdr_ArchiveSubscribeInfoCctrl (xdrs, &objp->TdtSubscriptionInfoCctrl_u.archiveInfo))
			 return FALSE;
		break;
	case TDT_ACTUALSIGNALINDICATIONS:
		 if (!xdr_bool (xdrs, &objp->TdtSubscriptionInfoCctrl_u.withRedGreenStates))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_R09TelegramCctrl (XDR *xdrs, R09TelegramCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_bytes (xdrs, (char **)&objp->R09TelegramCctrl_val, (u_int *) &objp->R09TelegramCctrl_len, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_AmliDtosCctrl (XDR *xdrs, AmliDtosCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->AmliDtosCctrl_val, (u_int *) &objp->AmliDtosCctrl_len, ~0,
		sizeof (AmliDtoCctrl), (xdrproc_t) xdr_AmliDtoCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TypOfRideCctrl (XDR *xdrs, TypOfRideCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RideExtensionSelector (XDR *xdrs, RideExtensionSelector *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RideExtensionCctrl (XDR *xdrs, RideExtensionCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_RideExtensionSelector (xdrs, &objp->selector))
		 return FALSE;
	switch (objp->selector) {
	case RES_estimatedGreenDurationNeeded:
		 if (!xdr_int (xdrs, &objp->RideExtensionCctrl_u.estimatedGreenDurationNeeded))
			 return FALSE;
		break;
	case RES_priority:
		 if (!xdr_int (xdrs, &objp->RideExtensionCctrl_u.priority))
			 return FALSE;
		break;
	case RES_vehicleType:
		 if (!xdr_TypOfRideCctrl (xdrs, &objp->RideExtensionCctrl_u.vehicleType))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_IntersectionRideCctrl (XDR *xdrs, IntersectionRideCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_quad_t (xdrs, &objp->id))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->ptDirectionNo))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->ptSgNo))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->estimatedStartTimeOfGreen))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->extensionList.extensionList_val, (u_int *) &objp->extensionList.extensionList_len, ~0,
		sizeof (RideExtensionCctrl), (xdrproc_t) xdr_RideExtensionCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_IntersectionRidesCctrl (XDR *xdrs, IntersectionRidesCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->activeRideList.activeRideList_val, (u_int *) &objp->activeRideList.activeRideList_len, ~0,
		sizeof (IntersectionRideCctrl), (xdrproc_t) xdr_IntersectionRideCctrl))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->timeOfLastUpdate))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CycleTimelineEntryTypeCctrl (XDR *xdrs, CycleTimelineEntryTypeCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CteCyclicCctrl (XDR *xdrs, CteCyclicCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->cycleTime))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->cycleStartTime))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CteStallingCctrl (XDR *xdrs, CteStallingCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->cycleTimeCounter))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CteSpecificCctrl (XDR *xdrs, CteSpecificCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_CycleTimelineEntryTypeCctrl (xdrs, &objp->cteType))
		 return FALSE;
	switch (objp->cteType) {
	case CTE_Cyclic:
		 if (!xdr_CteCyclicCctrl (xdrs, &objp->CteSpecificCctrl_u.cyclic))
			 return FALSE;
		break;
	case CTE_Stalling:
		 if (!xdr_CteStallingCctrl (xdrs, &objp->CteSpecificCctrl_u.stalling))
			 return FALSE;
		break;
	case CTE_Invalid:
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_CycleTimelineEntryCctrl (XDR *xdrs, CycleTimelineEntryCctrl *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_quad_t (xdrs, &objp->startTick))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->prio))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->signalProgram))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->signalProgramSysJobId))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->prio);
		IXDR_PUT_LONG(buf, objp->signalProgram);
		IXDR_PUT_LONG(buf, objp->signalProgramSysJobId);
		}
		 if (!xdr_CteSpecificCctrl (xdrs, &objp->s))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_quad_t (xdrs, &objp->startTick))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->prio))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->signalProgram))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->signalProgramSysJobId))
				 return FALSE;

		} else {
		objp->prio = IXDR_GET_LONG(buf);
		objp->signalProgram = IXDR_GET_LONG(buf);
		objp->signalProgramSysJobId = IXDR_GET_LONG(buf);
		}
		 if (!xdr_CteSpecificCctrl (xdrs, &objp->s))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_quad_t (xdrs, &objp->startTick))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->prio))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->signalProgram))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->signalProgramSysJobId))
		 return FALSE;
	 if (!xdr_CteSpecificCctrl (xdrs, &objp->s))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_CycleTimelineCctrl (XDR *xdrs, CycleTimelineCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_quad_t (xdrs, &objp->baseTick))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->entries.entries_val, (u_int *) &objp->entries.entries_len, ~0,
		sizeof (CycleTimelineEntryCctrl), (xdrproc_t) xdr_CycleTimelineEntryCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TaLockStateCctrl (XDR *xdrs, TaLockStateCctrl *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TaLocksCctrl (XDR *xdrs, TaLocksCctrl *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_vector (xdrs, (char *)objp->subIntersection, 4,
		sizeof (TaLockStateCctrl), (xdrproc_t) xdr_TaLockStateCctrl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_detstates_8_argument (XDR *xdrs, detstates_8_argument *objp)
{
	 if (!xdr_DetRawValuesExchg (xdrs, &objp->values))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->seqNr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_actualsignalindications_8_argument (XDR *xdrs, actualsignalindications_8_argument *objp)
{
	 if (!xdr_SignalIndicationsCctrl (xdrs, &objp->values))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->seqNr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_actualstatus_8_argument (XDR *xdrs, actualstatus_8_argument *objp)
{
	 if (!xdr_ActualStatusCctrl (xdrs, &objp->values))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->seqNr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_requestedstatus_8_argument (XDR *xdrs, requestedstatus_8_argument *objp)
{
	 if (!xdr_RequestedStatusCctrl (xdrs, &objp->rs))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->seqNr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_targetstage_8_argument (XDR *xdrs, targetstage_8_argument *objp)
{
	 if (!xdr_TargetStagePtr (xdrs, &objp->ts))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->devTick))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->seqNr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_intersectionrides_8_argument (XDR *xdrs, intersectionrides_8_argument *objp)
{
	 if (!xdr_IntersectionRidesCctrl (xdrs, &objp->rides))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->seqNr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_devicevalues_8_argument (XDR *xdrs, devicevalues_8_argument *objp)
{
	 if (!xdr_DeviceValuesCctrl (xdrs, &objp->values))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->seqNr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_rideevent_8_argument (XDR *xdrs, rideevent_8_argument *objp)
{
	 if (!xdr_RideEventCctrl (xdrs, &objp->r09))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->seqNr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_reportallqueuesareidle_8_argument (XDR *xdrs, reportallqueuesareidle_8_argument *objp)
{
	 if (!xdr_bool (xdrs, &objp->isReportRequested))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->seqNr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_subscribe4tdt_8_argument (XDR *xdrs, subscribe4tdt_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->inetadr, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_TdtSubscriptionInfoCctrl (xdrs, &objp->si))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_unsubscribe4tdt_8_argument (XDR *xdrs, unsubscribe4tdt_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->inetadr, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_MkjtricDataTypeCctrl (xdrs, &objp->tdt))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_allqueuesareidle_8_argument (XDR *xdrs, allqueuesareidle_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->inetadr, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->seqNr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_renew_8_argument (XDR *xdrs, renew_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->inetadr, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_getearliesttime4stagetransition_8_argument (XDR *xdrs, getearliesttime4stagetransition_8_argument *objp)
{
	 if (!xdr_quad_t (xdrs, &objp->notBeforeTime))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->toStage))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_checkadddesiredstageswitchingevents_8_argument (XDR *xdrs, checkadddesiredstageswitchingevents_8_argument *objp)
{
	 if (!xdr_ExternalStageSwitchingEventArray (xdrs, &objp->stageSwitchingEvents))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->allowedTypesOfViolation))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setintersectionstate_8_argument (XDR *xdrs, setintersectionstate_8_argument *objp)
{
	 if (!xdr_RequestedStatusPriorityCctrl (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_RequestedMainNodeStateCctrl (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->durationInMs))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setsubintersectionstate_8_argument (XDR *xdrs, setsubintersectionstate_8_argument *objp)
{
	 if (!xdr_RequestedStatusPriorityCctrl (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_RequestedNodeStateCctrl (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->key))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->durationInMs))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setsignalprogram_8_argument (XDR *xdrs, setsignalprogram_8_argument *objp)
{
	 if (!xdr_RequestedStatusPriorityCctrl (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->durationInMs))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setspecialintervention_8_argument (XDR *xdrs, setspecialintervention_8_argument *objp)
{
	 if (!xdr_RequestedStatusPriorityCctrl (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->durationInMs))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setmodvastate_8_argument (XDR *xdrs, setmodvastate_8_argument *objp)
{
	 if (!xdr_RequestedStatusPriorityCctrl (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_RequestedModificationStateCctrl (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->durationInMs))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setmodivstate_8_argument (XDR *xdrs, setmodivstate_8_argument *objp)
{
	 if (!xdr_RequestedStatusPriorityCctrl (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_RequestedModificationStateCctrl (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->durationInMs))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setmodoevstate_8_argument (XDR *xdrs, setmodoevstate_8_argument *objp)
{
	 if (!xdr_RequestedStatusPriorityCctrl (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_RequestedModificationStateCctrl (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->durationInMs))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setsynchronizationstate_8_argument (XDR *xdrs, setsynchronizationstate_8_argument *objp)
{
	 if (!xdr_RequestedStatusPriorityCctrl (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_RequestedModificationStateCctrl (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->durationInMs))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setprojectspecificmodstate_8_argument (XDR *xdrs, setprojectspecificmodstate_8_argument *objp)
{
	 if (!xdr_RequestedStatusPriorityCctrl (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_RequestedModificationStateCctrl (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->key))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->durationInMs))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_settaactualstatus_8_argument (XDR *xdrs, settaactualstatus_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->host, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_TTVModOnOffStateCctrlA (xdrs, &objp->taStates))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_getdraftcomponentparams_8_argument (XDR *xdrs, getdraftcomponentparams_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->componentName, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->inetadr, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setcltstatus_8_argument (XDR *xdrs, setcltstatus_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->host, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_CltStatusMsgsCctrl (xdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_archivegetlaterthan_8_argument (XDR *xdrs, archivegetlaterthan_8_argument *objp)
{
	 if (!xdr_ArchiveSelectorCctrl (xdrs, &objp->selector))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->primaryKey))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->start))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->maxCount))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_addmsgresetarchive_8_argument (XDR *xdrs, addmsgresetarchive_8_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_MsgParameterCctrl (xdrs, &objp->archiveType))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setaggregationcycle_8_argument (XDR *xdrs, setaggregationcycle_8_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->samplingInterval))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->offset))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_forwardptrequest_8_argument (XDR *xdrs, forwardptrequest_8_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	 if (!xdr_R09TelegramCctrl (xdrs, &objp->telegram))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_getdraftintersectionversionasxmlstring_8_argument (XDR *xdrs, getdraftintersectionversionasxmlstring_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->inetadr, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_getdraftsystemconfigversionasxmlstring_8_argument (XDR *xdrs, getdraftsystemconfigversionasxmlstring_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->inetadr, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_getdraftselectedcfg_8_argument (XDR *xdrs, getdraftselectedcfg_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->inetadr, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_CfgSelector (xdrs, &objp->arg3))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_registerasconfigconsumer_8_argument (XDR *xdrs, registerasconfigconsumer_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->inetadr, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->configTypeSet))
		 return FALSE;
	 if (!xdr_UnitId (xdrs, &objp->uid))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_unregisterasconfigconsumer_8_argument (XDR *xdrs, unregisterasconfigconsumer_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->inetadr, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->configTypeSet))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_registerdevicevariableprovider_8_argument (XDR *xdrs, registerdevicevariableprovider_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->inetadr, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->tcpPort))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->dvpName, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->dvpVersion, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setsplcycletimecounterto_8_argument (XDR *xdrs, setsplcycletimecounterto_8_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->signalProgramNumber))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->newCycleTimeCounterValue))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->atTickTime))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->durationMs))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_InitiatorCCtrl (xdrs, &objp->initiator))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_stallsplcycletimecounterto_8_argument (XDR *xdrs, stallsplcycletimecounterto_8_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->signalProgramNumber))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->newCycleTimeCounterValue))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->atTickTime))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->durationMs))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_InitiatorCCtrl (xdrs, &objp->initiator))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_invalidatecycletimecounterat_8_argument (XDR *xdrs, invalidatecycletimecounterat_8_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->signalProgramNumber))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->atTickTime))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->durationMs))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_InitiatorCCtrl (xdrs, &objp->initiator))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_prepare4shutdown2update_8_argument (XDR *xdrs, prepare4shutdown2update_8_argument *objp)
{
	 if (!xdr_bool (xdrs, &objp->useEmergencyOpMode))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->sysJobId))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_settalock_8_argument (XDR *xdrs, settalock_8_argument *objp)
{
	 if (!xdr_string (xdrs, &objp->host, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_TaLocksCctrl (xdrs, &objp->locks))
		 return FALSE;
	return TRUE;
}
