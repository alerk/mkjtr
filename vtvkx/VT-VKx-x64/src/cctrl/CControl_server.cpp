/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "CControl.h"
#include "Archive.h"
#include "wrappedCctrlDtos.h"
#include <stdio.h>
#include <atomic>
#include "instregistry.h"
#include "mv/Detectors.h"
#include "start/awpWrapper.h"
#include "util/repdef.h"
#include <cctrl/cltDeviceValues.h>
#include <util/StateMessage.h>
#include "cctrl/nlsPropertyProvider.h"
#include "cctrl/PublicTransport.h"
#include "cctrl/ConfigNotificationImpl.h"

#if defined(WIN32) && defined(__cplusplus)
extern "C" void xdr_free (xdrproc_t __proc, char *__objp) ;
extern "C" void xdrmem_create (XDR *__xdrs, const caddr_t __addr, u_int __size, enum xdr_op __xop) ;
#endif

#include "util/what.h"
DEFINE_WHATINFO;




//const char * svc_reqtop(struct svc_req *rqstp)
//  {
//    static char buf[128];
//    inet_ntop(rqstp->rq_xprt->xp_raddr.sin_family, rqstp->rq_xprt->xp_raddr.sin_addr, buf, sizeof buf);
//  }

  /**
   * @param seqNr seq nr of current call
   * @return true if seqNr is expected, false if seqNr is unexpected.
   */
  static bool checkSeqNr(int seqNr)
  {
    static std::atomic_int nextSeqNr(0);
    bool ret;
    const int expected=nextSeqNr.fetch_add(1);
    if ( expected != seqNr)
    {
      Report(DET_WARNING, "got unexpected seqNr=%d expectedSeqNr=%d" , seqNr, expected);
      nextSeqNr = seqNr+1;
      ret = false;
    }
    else
    {
      ret = true;
    }
    return ret;
  }


bool_t
getreleasedversionccontroldatareceiver_8_svc(int *result, struct svc_req * /*rqstp*/)
{
	/*
	 * insert server code here
	 */
	*result = CCONTROL_RELEASE_VERS;

	return 0;
}

bool_t
detstates_8_svc(DetRawValuesExchg values, int seqNr, void * /*result*/,  struct svc_req * /*rqstp*/)
{
    checkSeqNr(seqNr);
  sitraffic::InstRegistry::Instance().getDetectors().onNewValues100ms(values);
	return 0;
}

typedef bool_t *(* xdr_setpos_t)(XDR *__xdrs, u_int __len);
template <typename T> bool_t xdrdeepcopy( T & src, T & dst, bool_t (*xdrfkt)(XDR* xdrs, T *pv))
  {
    char xdrbuf[8192];
    XDR xdr;
    xdrmem_create(&xdr, xdrbuf, sizeof xdrbuf, XDR_FREE);
    if(!xdrfkt(&xdr, &dst)) return FALSE;
    memset(&dst, 0, sizeof (T) );
    (* ((xdr_setpos_t)(xdr.x_ops->x_setpostn)))(&xdr,0);
    xdr.x_op=XDR_ENCODE;
    if(!xdrfkt(&xdr, &src)) return FALSE;
    (* ((xdr_setpos_t)(xdr.x_ops->x_setpostn)))(&xdr,0);
    xdr.x_op=XDR_DECODE;
    return xdrfkt(&xdr, &dst);
  }

bool_t
actualsignalindications_8_svc(SignalIndicationsCctrl si, int seqNr, void * /*result*/,  struct svc_req * /*rqstp*/)
{
  static sitraffic::SignalIndicationsWCctrl ssi; // copy of si at static memory since si may be overwritten
  //static SignalIndicationCctrl ssii[96];
	bool_t isPrint = ssi.getSgPatterns().empty();

	setCurrentReportTicks(ssi.baseTicktime);

	checkSeqNr(seqNr);
        // clone si
        ssi=si;
//        ssi.sgPatterns.sgPatterns_val = &ssii[0];
//        for(unsigned i=0; i< si.sgPatterns.sgPatterns_len; i++)
//          {
//            ssi.sgPatterns.sgPatterns_val[i] = si.sgPatterns.sgPatterns_val[i];
//          }


        // print it out only the first update
        if(isPrint)
        {
         // fprintf(stderr, "SignalIndications btt=%lld tx=%6lld sq=%5d %u ", si.baseTicktime, si.tx, seqNr, si.sgPatterns.sgPatterns_len);
         // for(unsigned i=0; i< si.sgPatterns.sgPatterns_len; i++)
         // {
         //   ocit2char(stderr, si.sgPatterns.sgPatterns_val[i].ocitColor);
         // }
         // fprintf(stderr, "\n");

            Report(SIGNALGROUP_EVENT, "seqNr=%d, SignalIndicationsCctrl: TX=%" PRId64" UTC-tick=%" PRId64" tick=%" PRId64" sg count=%u %s",
                                seqNr, si.tx, si.baseUtcMinusTicktime, si.baseTicktime, si.sgPatterns.sgPatterns_len, ssi.getDecodedSgPattern().c_str());
        }
        else
        {
            ReportC(SIGNALGROUP_DEBUG|R_THREAD), "seqNr=%d, SignalIndicationsCctrl: TX=%" PRId64" UTC-tick=%" PRId64" tick=%" PRId64" sg count=%u %s",
                       seqNr, si.tx, si.baseUtcMinusTicktime, si.baseTicktime, si.sgPatterns.sgPatterns_len, ssi.getDecodedSgPattern().c_str());

        }

        sitraffic::InstRegistry::Instance().set(ssi);
        sitraffic::InstRegistry::Instance().getAwpWrapper().onSignalIndication(ssi);

        sitraffic::flushStateMessages();
        flushReport();
	return 0;       // send no result
}

const char * getModStateStr(const ActualStatusCctrl& as)
  {
    static char buff[30];
    int used = 0;
    for(unsigned i = 0; i < as.modifications.modifications_len; i++)
    {
       TTVModOnOffStateCctrl * ms = &as.modifications.modifications_val[i];
       if(ms->modType == i)
         used +=  snprintf(buff + used, sizeof(buff) - used, "%d|",  ms->value);
       else
         used +=  snprintf(buff + used, sizeof(buff) - used, "%d=%d|", ms->modType, ms->value);
    }
    return buff;
  }

bool equalsModState(const ActualStatusCctrl& as1, const ActualStatusCctrl& as2)
{
   if( as1.modifications.modifications_len !=  as2.modifications.modifications_len)
     return false;

    for(unsigned i = 0; i < as1.modifications.modifications_len; i++)
    {
       TTVModOnOffStateCctrl * ms1 = &as1.modifications.modifications_val[i];
       TTVModOnOffStateCctrl * ms2 = &as2.modifications.modifications_val[i];
       if(ms1->modType != ms2->modType || ms1->value != ms2->value)
         return false;
    }
    return true;
  }



bool_t actualstatus_8_svc(ActualStatusCctrl values, int seqNr, void * /*result*/, struct svc_req * /*rqstp*/)
  {
    static sitraffic::ActualStatusWCctrl sActualStatus;
    bool_t retval = TRUE;       // sendresult
    checkSeqNr(seqNr);

    if( sActualStatus.signalProgram          != values.signalProgram
     || sActualStatus.globalFaultState       != values.globalFaultState
     || sActualStatus.operatingMode          != values.operatingMode
     || sActualStatus.intersectionOnOffState != values.intersectionOnOffState
     || ! equalsModState(sActualStatus, values))
      {
    	if(values.signalProgram == 0 && values.intersectionOnOffState == IS_ON)
    	{
    	  // pdm will probably hang-up in TL code
          Report(RUNMODE_WARNING, "seqNr:%d NO_signalProgram!!! globalFaultState:%d operatingMode:%d intersectionOnOffState:%d modStates:%s",
                   seqNr, values.globalFaultState, values.operatingMode,
                   values.intersectionOnOffState, getModStateStr(values));
    	}
    	else
    	{
          Report(RUNMODE_STATE, "seqNr:%d signalProgram:%d globalFaultState:%d operatingMode:%d intersectionOnOffState:%d modStates:%s",
                 seqNr, values.signalProgram, values.globalFaultState, values.operatingMode,
                 values.intersectionOnOffState, getModStateStr(values));
    	}
      }
      else
      {
        Report(RUNMODE_INFO, "seqNr:%d signalProgram:%d globalFaultState:%d operatingMode:%d intersectionOnOffState:%d modStates:%s",
				seqNr, values.signalProgram, values.globalFaultState, values.operatingMode,
				values.intersectionOnOffState, getModStateStr(values));
      }

    // rpc generated code allocates dynamic length arrays, we take them over avoid release.
    xdrdeepcopy(values, sActualStatus.base(), xdr_ActualStatusCctrl);
    sitraffic::InstRegistry::Instance().set(sActualStatus);

    return retval;
  }



const char * getModStateStr(const RequestedStatusCctrl& rs)
  {
    static char buff[30];
    int used = 0;
    for(unsigned i = 0; i < rs.modState.modState_len; i++)
    {
       TcTTVModOnOffStateCctrl * ms = &rs.modState.modState_val[i];
       if(ms->modType == i)
         used +=  snprintf(buff + used, sizeof(buff) - used, "%d|",  ms->value);
       else
         used +=  snprintf(buff + used, sizeof(buff) - used, "%d=%d|", ms->modType, ms->value);
    }
    return buff;
  }

bool_t requestedstatus_8_svc(RequestedStatusCctrl rs, int seqNr, void * /*result*/, struct svc_req * /*rqstp*/)
  {
    static int lastSignalProgram = 0;
    static sitraffic::RequestedStatusWCctrl sRequestedStatus;
    bool_t retval = TRUE;       // sendresult
    checkSeqNr(seqNr);
    xdrdeepcopy(rs, sRequestedStatus.base(), xdr_RequestedStatusCctrl);

    Report(RUNMODE_EVENT, "seqNr:%d lastSignalProgram:%d signalProgram:%d intersectionState:%d isAtleastOnePiOn:%d modStates:%s",
             seqNr, lastSignalProgram, sRequestedStatus.signalProgram.value,
             sRequestedStatus.intersectionState.value, sRequestedStatus.isAtleastOnePiOn(), getModStateStr(sRequestedStatus));

    if(lastSignalProgram != rs.signalProgram.value)
    {
     // if(lastSignalProgram != 0)
     //   sitraffic::updateStateMessages(TRUE);
      lastSignalProgram = rs.signalProgram.value;
    }

    sitraffic::InstRegistry::Instance().set(sRequestedStatus);


    return retval;
  }

bool_t
targetstage_8_svc(TargetStagePtr /*ts*/, int64_t /*devTick*/, int seqNr, void * /*result*/,  struct svc_req * /*rqstp*/)
{
	bool_t retval=0;
        checkSeqNr(seqNr);

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
intersectionrides_8_svc(IntersectionRidesCctrl /*rides*/, int seqNr, void * /*result*/,  struct svc_req * /*rqstp*/)
{
	bool_t retval=0;
        checkSeqNr(seqNr);

	/*
	 * insert server code here
	 */

	return retval;
}

static TacRideEventSource rideEventSourceCctrlToTac(RideEventSourceCctrl eventSource)
{
    switch (eventSource) {
        case RESC_AFD:
            return TAC_RES_AFD;
        case RESC_Det:
            return TAC_RES_Det;
        case RESC_ITCS:
            return TAC_RES_ITCS;
        case RESC_RideManager:
            return TAC_RES_RideManager;
        case RESC_SimGui:
            return TAC_RES_SimGui;
        case RESC_unknown:
            return TAC_RES_unknown;
        default:
            Report(TAC_ERROR, "unknown RideEventSourceCctrl used %d", eventSource);
            return TAC_RES_unknown;

    }
}

static USHORT toUShort(int lrd)
{
	if(lrd < 0)
		return 0;
	return (USHORT)lrd;
}

bool_t rideevent_8_svc(RideEventCctrl r09, int seqNr, void * /*result*/, struct svc_req * /*rqstp*/)
{
    checkSeqNr (seqNr);

    // avoid duplicates --> OevSpeicher
    //if(r09.source == RESC_Det)
    //	return TRUE;

    sitraffic::PublicTransport &pt = sitraffic::InstRegistry::Instance().getPublicTransport();
    TacRideEvent tele;

    tele.source = rideEventSourceCctrlToTac(r09.source);
    tele.reportingPointNo = (USHORT)r09.rpNo;
    tele.lineNo = toUShort(r09.lineNo);
    tele.runNo = toUShort(r09.runNo);
    tele.destinationNo = toUShort(r09.destinationNo);
    tele.imbalance = 0;
    tele.priority = 0;
    tele.manualDirection = 0;
    tele.vehicleLength = 0;
    tele.ptDirectionNo = 0;
    for (int i = 0; i < (int)r09.attrs.attrs_len; i++) {
        switch(r09.attrs.attrs_val[i].selector) {
            case R09_Imbalance:
                tele.imbalance = (SSHORT)r09.attrs.attrs_val[i].value;
                break;
            case R09_Priority:
                tele.priority = (USHORT)r09.attrs.attrs_val[i].value;
                break;
            case R09_ManDir:
                tele.manualDirection = (USHORT)r09.attrs.attrs_val[i].value;
                break;
            case R09_VehicleLen:
                tele.vehicleLength = (USHORT)r09.attrs.attrs_val[i].value;
                break;
            case R09_PtDirectionNo:
			   tele.ptDirectionNo = (USHORT)r09.attrs.attrs_val[i].value;
			   break;
            case R09_VehicleNo:
            case R09_CompanyNo:
            case R09_PtDetNo:
            case R09_Unknown:
            default:
                break;
        }
    }
    pt.addPtTelegram(&tele);
    /*
     * insert server code here
     */
    return TRUE;
}

bool_t
devicevalues_8_svc(DeviceValuesCctrl /*values*/, int seqNr, void * /*result*/,  struct svc_req * /*rqstp*/)
{
	bool_t retval=0;
        checkSeqNr(seqNr);

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
reportallqueuesareidle_8_svc(bool_t /*isReportRequested*/, int seqNr, void * /*result*/,  struct svc_req * /*rqstp*/)
{
	bool_t retval=0;
        checkSeqNr(seqNr);

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
checkconfig_8_svc(int configTypeSet, CheckRespondCctrl *result,  struct svc_req * /*rqstp*/)
{
	/*
	 * insert server code here
	 */
    memset(result, 0, sizeof(*result));
    sitraffic::InstRegistry::Instance().getConfigNotification().doCheckConfig(configTypeSet, result);
//	CheckRespondCctrl & cr(*result);
//	cr.result = CR_REFUSE;
//	cr.Messages.Messages_len=0;
//	cr.Messages.Messages_val=0;
	return TRUE;
}

bool_t
activate_8_svc(int sysJobId, void * /*result*/,  struct svc_req * /*rqstp*/)
{
        sitraffic::InstRegistry::Instance().getConfigNotification().doActivate(sysJobId);

	return TRUE;
}

bool_t
cleanupconfigcheck_8_svc(void * /*result*/,  struct svc_req * /*rqstp*/)
{

        sitraffic::InstRegistry::Instance().getConfigNotification().doCleanupConfigCheck();

	return TRUE;
}

bool_t
archiveinsertevent_8_svc(enum ArchiveSelectorCctrl selector, void * /*result*/,  struct svc_req * /*rqstp*/)
{
	bool_t retval=0;

    Report(RUNMODE_EVENT, "archiveinsertevent_8_svc, selector=%d", selector);

    sitraffic::InstRegistry::Instance().getArchive().onNewValues(selector);

	return retval;
}

bool_t
subscribedevicevariables_8_svc(OitdCctrlA oitds, enum RetCodeCctrl *result,  struct svc_req * /*rqstp*/)
{
    Report(DEVVAR_INFO, "subscribedevicevariables_8_svc()");

    sitraffic::InstRegistry::Instance().getCltDeviceValueProviders().subscribe(oitds);
    *result = RC_OK;

    return TRUE; // sendresult
}

bool_t
unsubscribedevicevariables_8_svc(OitdCctrlA oitds, enum RetCodeCctrl *result,  struct svc_req * /*rqstp*/)
{
    Report(DEVVAR_INFO, "unsubscribedevicevariables_8_svc()");

    sitraffic::InstRegistry::Instance().getCltDeviceValueProviders().unsubscribe(oitds);
    *result = RC_OK;

    return TRUE; // sendresult
}

bool_t
getdevicevaluesmetadata_8_svc(DeviceValuesMetaDataCctrl *result, struct svc_req * /*rqstp*/)
{
        Report(DEVVAR_INFO, "getdevicevaluesmetadata_8_svc()");

	sitraffic::InstRegistry::Instance().getCltDeviceValueProviders().getMetadata(result);

	return TRUE; // sendresult
}

bool_t
getnlsdefinitions_8_svc(NlsMappingsCctrl *result, struct svc_req * /*rqstp*/)
{
	sitraffic::NlsPropertyProvider::fill(*result);

	return TRUE; // sendresult
}
/* ================ end of CcontrolDataReceiver service ==================================== */

int
ccontroldatareceiver_8_freeresult (SVCXPRT * /*transp*/, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}

//bool_t
//getreleasedversionccontrolservice_8_svc(int *result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//subscribe4tdt_8_svc(char *inetadr, int port, TdtSubscriptionInfoCctrl si, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//unsubscribe4tdt_8_svc(char *inetadr, int port, enum MkjtricDataTypeCctrl tdt, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//allqueuesareidle_8_svc(char *inetadr, int port, int seqNr, void *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//renew_8_svc(char *inetadr, int port, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//adddesiredsgswitchingevents_8_svc(ExternalSgSwitchingEventArray sgSwitchingEvents, void *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//adddesiredstageswitchingevents_8_svc(ExternalStageSwitchingEventArray stageSwitchingEvents, void *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getearliesttime4stagetransition_8_svc(int64_t notBeforeTime, int toStage, int64_t *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//checkadddesiredstageswitchingevents_8_svc(ExternalStageSwitchingEventArray stageSwitchingEvents, int allowedTypesOfViolation, bool_t *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setintersectionstate_8_svc(enum RequestedStatusPriorityCctrl priority, enum RequestedMainNodeStateCctrl value, int sysJobId, int64_t durationInMs, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setsubintersectionstate_8_svc(enum RequestedStatusPriorityCctrl priority, enum RequestedNodeStateCctrl value, int sysJobId, int key, int64_t durationInMs, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setsignalprogram_8_svc(enum RequestedStatusPriorityCctrl priority, int value, int sysJobId, int64_t durationInMs, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setspecialintervention_8_svc(enum RequestedStatusPriorityCctrl priority, int value, int sysJobId, int64_t durationInMs, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setmodvastate_8_svc(enum RequestedStatusPriorityCctrl priority, RequestedModificationStateCctrl value, int sysJobId, int64_t durationInMs, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setmodivstate_8_svc(enum RequestedStatusPriorityCctrl priority, RequestedModificationStateCctrl value, int sysJobId, int64_t durationInMs, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setmodoevstate_8_svc(enum RequestedStatusPriorityCctrl priority, RequestedModificationStateCctrl value, int sysJobId, int64_t durationInMs, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setsynchronizationstate_8_svc(enum RequestedStatusPriorityCctrl priority, RequestedModificationStateCctrl value, int sysJobId, int64_t durationInMs, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setprojectspecificmodstate_8_svc(enum RequestedStatusPriorityCctrl priority, RequestedModificationStateCctrl value, int sysJobId, int key, int64_t durationInMs, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//droppriority_8_svc(enum RequestedStatusPriorityCctrl priority, void *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//clearall_8_svc(void *result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//settaactualstatus_8_svc(char *host, int port, TTVModOnOffStateCctrlA taStates, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getcomponentparams_8_svc(char *componentName, MkjtricActuationComponentParamsResult *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getdraftcomponentparams_8_svc(char *componentName, char *inetadr, int port, MkjtricActuationComponentParamsResult *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setcltstatus_8_svc(char *host, int port, CltStatusMsgsCctrl status, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//archivegetoldest_8_svc(enum ArchiveSelectorCctrl selector, ArchiveResultCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//archivegetyoungest_8_svc(enum ArchiveSelectorCctrl selector, ArchiveResultCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//archivegetlaterthan_8_svc(enum ArchiveSelectorCctrl selector, int64_t primaryKey, int64_t start, int maxCount, ArchiveResultArrayCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//addmsgresetarchive_8_svc(int sysJobId, MsgParameterCctrl archiveType, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getaggregationcycle_8_svc(AggregationCycleResultCctrl *result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setaggregationcycle_8_svc(int samplingInterval, int offset, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getaggregationsignalling_8_svc(AggregationSignallingResultCctrl *result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setaggregationsignalling_8_svc(int maxSamplingInterval, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//forwardptrequest_8_svc(int sysJobId, R09TelegramCctrl telegram, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getintersectionversionasxmlstring_8_svc(char **result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getsystemconfigversionasxmlstring_8_svc(char **result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getdraftintersectionversionasxmlstring_8_svc(char *inetadr, int port, char **result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getdraftsystemconfigversionasxmlstring_8_svc(char *inetadr, int port, char **result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getversions_8_svc(VersionsCctrl *result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getcantonetconfig_8_svc(CantoNetConfigCctrl *result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getselectedcfg_8_svc(enum CfgSelector arg1, SelectedConfig *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getdraftselectedcfg_8_svc(char *inetadr, int port, enum CfgSelector arg3, SelectedConfig *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getselectedcfginfo_8_svc(enum CfgInfoSelector selector, SelectedCfgInfo *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getconfigdatainfoznr_8_svc(int *result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getconfigdatainfofnr_8_svc(int *result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//registerasconfigconsumer_8_svc(char *inetadr, int port, int configTypeSet, enum UnitId uid, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//unregisterasconfigconsumer_8_svc(char *inetadr, int port, int configTypeSet, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//registerdevicevariableprovider_8_svc(char *inetadr, int port, int tcpPort, char *dvpName, char *dvpVersion, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setdevicevalues_8_svc(DeviceValuesCctrl dvs, void *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//subscribe4devicevariables_8_svc(OitdCctrlA oitds, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//unsubscribe4devicevariables_8_svc(OitdCctrlA oitds, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//unsubscribealldevicevariables_8_svc(enum RetCodeCctrl *result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//checkifoitdexists_8_svc(OitdCctrl oitd, bool_t *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getdevicevaluesmetadatalist_8_svc(DeviceValuesMetaDataCctrlA *result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//setsplcycletimecounterto_8_svc(int signalProgramNumber, int newCycleTimeCounterValue, int64_t atTickTime, int durationMs, int priority, InitiatorCCtrl initiator, int sysJobId, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//stallsplcycletimecounterto_8_svc(int signalProgramNumber, int newCycleTimeCounterValue, int64_t atTickTime, int durationMs, int priority, InitiatorCCtrl initiator, int sysJobId, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//invalidatecycletimecounterat_8_svc(int signalProgramNumber, int64_t atTickTime, int durationMs, int priority, InitiatorCCtrl initiator, int sysJobId, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//resetcyclemonitor_8_svc(int partialIntersectionMask, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//getcycletimelinewithprioritylt_8_svc(int priority, CycleTimelineCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//resetfaultlock_8_svc(void *result, struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//prepare4shutdown2update_8_svc(bool_t useEmergencyOpMode, int sysJobId, char **result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//prepare4tashutdown2update_8_svc(int sysJobId, char **result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//isfeaturelicensed_8_svc(char *feature, char **result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//bool_t
//docontrolcenterif_8_svc(enum ProcessControl startStopRestart, enum RetCodeCctrl *result,  struct svc_req *rqstp)
//{
//	bool_t retval;
//
//	/*
//	 * insert server code here
//	 */
//
//	return retval;
//}
//
//int
//ccontrolservice_8_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
//{
//	xdr_free (xdr_result, result);
//
//	/*
//	 * Insert additional freeing code here, if needed
//	 */
//
//	return 1;
//}
